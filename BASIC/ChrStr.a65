;=================================================================== CHRSTR ===========
;*  Bin2Dec             Convert binary value in A (0-99) into BCD in A, (high digit in X)
;*  ChrCopy             Output characters from input (mem/device) to output(Mem/device)
;*  ChrIn               Read character from input device (KBD,COM..) -> CHRGOT
;*  ChrInit             Copy ZPg code, Vectors, Init print flags, Wr to STRBUF
;*  ChrOut              Send character to output device (SCR,COM..)
;*  ChrWr               Write character to (ZWr)
;*  CvtNum              Convert NUMBER to digits in CVTBUF
;*  Hex2Nib             '0..9A..F' -> to nibble in A (C=1 Valid) [A]
;*  Input               Read from Mem/IO and place in INBUF, until CR
;*  InputIO             input from IO
;*  InputIOEcho         Input from IO, also echo chars to IO
;*  NumD10              NUMBER = NUMBER / 10, remainder in A [AXY]
;*  NumM10              NUMBER = NUMBER * 10  (preserves AXY) - destorys NUMTMP
;*  NumZero             place zero into NUMBER
;*  PrAHex              Print A as Hex digits (send/write) [A]
;*  PrAXHex             Print AX(lo/hi) as 4 hex digits [A]
;*  PrCh                Print character - Write/Send as per flag
;*  PrNL                print CR,LF to CharOut
;*  PrNib               Convert hex nibble and Print it
;*  PrNum               print NUMBER as digits to output (mem/io)
;*  PrStr               Print string pointed to by ZPtr [A]
;*  PrStrAX             Print string at AX [A]
;*  PrStrBuf            Print STRBUF [A]
;*  PrTerm              write terminating null
;*  RdCh                read character from memory or input device -> A, CHRGOT
;*  RdNum               -- parse a number into NUMBER - destorys NUMTMP
;*  _Print_             Print in-line string
;*m BR_NBCD(tgt)        Branch to tgt if BCD=0
;*m BR_ND7(tgt)         Branch to tgt if MRK=0 (end with bit 7)
;*m BR_NRD(tgt)         Branch to tgt if Read=0
;*m BR_NWR(tgt)         Branch to tgt if Write=0
;*m PRINT(str)          Print in-line string
;*m PRINTLN(str)        Print in-line string with CR,LF
;*m PR_ALL()            Term Null F5=0 Term null only
;*m PR_ASCII()          Term Non-ASCII F5=1 Non-ASCII term
;*m PR_BCD_OFF()        HEX out  F4=0 HEX 0-9ABCDEF
;*m PR_BCD_ON()         BCD out  F4=1 BCD 0-9+-e.E
;*m PR_ECHO_OFF()       No Echo  F3=0
;*m PR_ECHO_ON()        ECHO the input F3=1 -> Chr
;*m PR_NECHO(tgt)       Branch to tgt if ECHO=0
;*m PR_RD_IO()          Read IO  F6=0 ChrIn
;*m PR_RD_MEM()         Read memory F6=1 ChrRd
;*m PR_WR_IO()          Write IO F7=0 ChrOut
;*m PR_WR_MEM()         Write memory F7=1 ChrWr
;*
#ifdef hide
.NOLIST
#endif
; ZPrFlg = Flag controls
 		;-- 0		1
; Bit7 PrCh	ChrOut 	IO	ChrWr MEM
; Bit6 RdCh	ChrIn  	IO	ChrRd MEM
; Bit5 Term	NULL 		Non-ASCII term
; Bit4 BCD	'0..9ABCDEF'	'0..9+-e.E '
; Bit3 Echo     No		Yes->PrCh
; Bit2
; Bit1
; Bit0

;----------------------------------------------- 7:Wr/Out
; BR_WR(tgt) Branch to tgt if Write=1
#define BR_WR(tgt) 	BBS7 ZPrFlg,tgt

; BR_NWR(tgt)	Branch to tgt if Write=0
#define BR_NWR(tgt) 	BBR7 ZPrFlg,tgt

; PR_WR_MEM()	Write memory	F7=1 ChrWr
#define PR_WR_MEM()	SMB7 ZPrFlg

; PR_WR_IO()	Write IO	F7=0 ChrOut
#define PR_WR_IO()	RMB7 ZPrFlg

;----------------------------------------------- 6:Rd/In
; BR_RD(tgt) Branch to tgt if Read=1
#define BR_RD(tgt) 	BBS6 ZPrFlg,tgt

; BR_NRD(tgt)	Branch to tgt if Read=0
#define BR_NRD(tgt) 	BBR6 ZPrFlg,tgt

; PR_RD_MEM()	Read memory	F6=1 ChrRd
#define PR_RD_MEM()	SMB6 ZPrFlg

; PR_RD_IO()	Read IO		F6=0 ChrIn
#define PR_RD_IO()	RMB6 ZPrFlg

;----------------------------------------------- 5:NonASCII
; BR_D7(tgt)	Branch to tgt if MRK=1 (end with bit 7)
#define BR_D7(tgt) 	BBS5 ZPrFlg,tgt
; BR_ND7(tgt)	Branch to tgt if MRK=0 (end with bit 7)
#define BR_ND7(tgt) 	BBR5 ZPrFlg,tgt

; PR_ASCII()	Term Non-ASCII	F5=1 Non-ASCII term
#define PR_ASCII()	SMB5 ZPrFlg

; PR_ALL()	Term Null	F5=0 Term null only
#define PR_ALL()	RMB5 ZPrFlg

;----------------------------------------------- 4:BCD HEX
; BR_BCD(tgt)	Branch to tgt if BCD=1
#define BR_BCD(tgt) 	BBS4 ZPrFlg,tgt
; BR_NBCD(tgt)	Branch to tgt if BCD=0
#define BR_NBCD(tgt) 	BBR4 ZPrFlg,tgt

; PR_BCD_ON()	BCD out		F4=1 BCD 0-9+-e.E
#define PR_BCD_ON()	SMB4 ZPrFlg

; PR_BCD_OFF()	HEX out		F4=0 HEX 0-9ABCDEF
#define PR_BCD_OFF()	RMB4 ZPrFlg

;----------------------------------------------- 3:Echo
; PR_ECHO(tgt)	Branch to tgt if ECHO=1
#define BR_ECHO(tgt) 	BBS3 ZPrFlg,tgt
; PR_NECHO(tgt)	Branch to tgt if ECHO=0
#define BR_NECHO(tgt) 	BBR3 ZPrFlg,tgt
; PR_ECHO_ON()	ECHO the input	F3=1 -> Chr
#define PR_ECHO_ON()	SMB3 ZPrFlg
; PR_ECHO_OFF()	No Echo		F3=0
#define PR_ECHO_OFF()	RMB3 ZPrFlg

; PRINT(str) 	Print in-line string
#define PRINT(str) 	jsr _Print_ \ .db "str",0

; PRINTLN(str) 	Print in-line string with CR,LF
#define PRINTLN(str) 	PRINT(str) \ jsr PrNL
 		;--
ChrRd 		= $0000 		; increment pointer and fetch, save in CHRGOT
ZRd 		= $07 			; points to character just fetched
CHRGOT 		= $0C 			; most recently fetched character
ZWr 		= $0E 			; address for ChrWr to write to

_ChrStr 	= $
;----------------------------------------------- ChrNext
; increment the ZRd pointer (inside the lda) and then fetch the character
RChrRd 		ZINC(ZRd) 		; 0001 0203 0405
 		LDA 	$1234 		; 060708
 		STA 	CHRGOT 		; 090A
 		RTS 			; 0B

.db $FF 				; 0C = CHRGOT
.db $FF 				; OD
.db 0,0 				; 0E0F = ZWr

; Initial values for 8 vectors in here, copied along with the above to zero page
 		;--
.dw ConIn 				; VCHRIN
.dw ConOut 				; VCHROUT
.dw $ABCD
.dw $ABCD
 		;--
.dw $ABCD
.dw $ABCD
.dw $ABCD
.dw $ABCD

;----------------------------------------------- CharInit
ChrInit: ; Copy ZPg code, Vectors, Init print flags, Wr to STRBUF
 		LDX 	#0
ChrInitL 	LDA 	RChrRd,X
 		STA 	$00,X
 		INX
 		CPX 	#$20 		; 16 code, 8 x vectors
 		BNE 	ChrInitL
 		;-- reset control flags
 		ZZERO(ZPrFlg) 		; reset flags ChrOut, Hex, NullTerm
 		;-- point writing to STRBUF
 		ZSET(ZWr,STRBUF)
 		RTS

Bin2DecTbl
.byte	$63,$31,$15,$07,$03,$01,$00

Nib2HexTbl
;    ____ BCD:0______===== BCD:1 ====
.db "0123456789ABCDEF0123456789+-e.E "
;   "0123456789ABCDEF0123456789abcdef"

;----------------------------------------------- PrTerm
PrTerm: ; write terminating null
 		LDA 	#0
;----------------------------------------------- PrCh
PrCh: ; Print character - Write/Send as per flag
 		;-- don't send null
 		CMP 	#0
 		BEQ 	ChrWrX
 		;-- outp[ut or memory
 		BR_WR(ChrWr) 		;wr=1?
 		;-- 0=fall through to send via ChrOut
;----------------------------------------------- ChrOut
ChrOut: ; Send character to output device (SCR,COM..)
 		JMP 	(VCHROUT)
;----------------------------------------------- ChrWr
ChrWr: ; Write character to (ZWr)
 		STA 	(ZWr)
 		;-- bump to next address
 		ZINC(ZWr)
 		;-- ensure terminating null
 		LDA 	#0
 		STA 	(ZWr)
ChrWrX 		RTS

;----------------------------------------------- RdCh
RdCh: ; read character from memory or input device -> A, CHRGOT
 		BR_NECHO(RdCh1) 	; if echo is off, just go get the char
 		JSR 	RdCh1 		; fetch char
 		BEQ 	RdChX 		; Null? ->exit (no echo)
 		PHA 			; save it
 		JSR 	ChrOut 		; echo to IO out
 		PLA 			; restore
RdChX 		RTS 			; return
; 1:ChrRd(mem) 0:ChrIn(IO)
RdCh1 		BR_NRD(ChrIn) 		;Rd=1? ChrRd
 		JMP 	ChrRd 		;ChrRd is code in Z Page, saves in CHRGOT

;----------------------------------------------- ChrIn
ChrIn: ; Read character from input device (KBD,COM..) -> CHRGOT
 		JSR 	ChrInV
 		STA 	CHRGOT
 		RTS
ChrInV 		JMP 	(VCHRIN)
;----------------------------------------------- ChrRd
;ChrRd is code in Z Page

;----------------------------------------------- ChrCopy
ChrCopy: ; Output characters from input (mem/device) to output(Mem/device)
 		JSR 	RdCh 		; get from Mem / IO
 		BEQ 	ChrCopyX 	; Null -> exit
 		BR_ND7(ChrCopy2) 	; MARK=Off, skip bit test
 		BMI 	ChrCopyX 	; bit 7 set -> exit
 		AND 	#$7F 		; force ascii
ChrCopy2 	JSR 	PrCh 		; put Mem / IO
 		BRA 	ChrCopy 	; loop
ChrCopyX 	RTS

;----------------------------------------------- InputIOEcho
InputIOEcho: ; Input from IO, also echo chars to IO
 		PR_WR_IO()
 		PR_ECHO_ON()
;----------------------------------------------- InputIO
InputIO: ; input from IO
 		PR_RD_IO() 		; Read from IO
;----------------------------------------------- Input
Input: ; Read from Mem/IO and place in INBUF, until CR
 		LDX 	#0
 		TXA
 		STA 	INBUF,x
InputL:  	JSR 	RdCh 		; get char from mem/io
; 		LDA 	CHRGOT
 		BEQ 	InputL
 		;-- ignore LF
 		CMP 	#LF
 		BEQ 	InputL
 		;-- exit on CR
 		CMP 	#CR
 		BEQ 	InputX
 		;-- back-space
 		CMP 	#BS
 		BNE 	Input1
 		;-- back & null
 		TAY 			; save BS char
 		LDA 	#0 		; null
 		STA 	INBUF,x 	; place in buf
 		DEX 			; back-up a position

 		STA 	INBUF,x 	; place in buf
 		TYA
Input1 		STA 	INBUF,x 	; place in buf
 		;-- check buffer full
 		CPX 	#BUFSZ
 		BPL 	InputX 		; full -> exit
 		;-- move on
 		INX
 		BRA 	InputL
InputX 		LDA 	#0 		; terminate with a null
 		STA 	INBUF,X
 		RTS

;----------------------------------------------- Bin2Dec
Bin2Dec: ; Convert binary value in A (0-99) into BCD in A, (high digit in X)
 		SED 			; all adds in decimal mode
 		STA 	ZTmp 		; save A
 		LDA 	#$00 		; clear A
 		LDX 	#$07 		; set bit count
Bin2DecL
 		LSR 	ZTmp 		; bit to carry
 		BCC 	Bin2DecS 	; branch if no add
 		ADC 	Bin2DecTbl-1,X 	; else add BCD value
Bin2DecS
 		DEX 			; decrement bit count
 		BNE 	Bin2DecL 	; loop if more to do
 		;-- 3digit {
 		BCC 	Bin2DecS1 	; branch if no 100's carry
 		;-- if Cb set here (and can only be set by the
 		;-- last loop add) then there was a carry into
 		INX 			; the 100's so add 100's carry to the high byte
Bin2DecS1
 		;-- now check the 2^7 (128) bit
 		LSR 	ZTmp 		; bit 7 to carry
 		BCC 	Bin2DecS2 	; branch if no add
 		INX 			; else effectively add 100 part of 128
 		ADC 	#$27 		; and then add 128 (-1) part of 128
 		BCC 	Bin2DecS2 	; branch if no further carry
 		INX 			; else add 200's carry
Bin2DecS2
 		;-- }
 		STA 	ZTmp 		; save result ZTmp byte
 		CLD 			; clear decimal mode
 		RTS

;----------------------------------------------- PrStrBuf
PrStrBuf: ; Print STRBUF [A]
 		LDAX(STRBUF)
;----------------------------------------------- PrStrAX
PrStrAX: ; Print string at AX [A]
 		SETAX(ZPtr)
;----------------------------------------------- PrStr
PrStr: ; Print string pointed to by ZPtr [A]
; last index saved into ZTmp
 		PHY
 		LDY 	#0
PrStr1 		LDA 	(ZPtr),y
 		BEQ 	PrStrX 		; zero -> exit
 		;-- end of bit 7=1 ?
 		BR_ND7(PrStr2) 		; MARK=Off, skip bit test
 		BMI 	PrStrX 		; bit 7 set -> exit
 		AND 	#$7F 		; force ascii
 		;--
PrStr2 		JSR 	PrCh 		; print character
 		INY 			; move to next char
 		BNE 	PrStr1 		; loop back (no more than 255 chars)
PrStrX 		STY 	ZTmp
 		PLY 			; restore Y
 		RTS 			; exit

;----------------------------------------------- _Print_
; PSEUDO-CODE
_Print_: ;Print in-line string
 		;-- pop the return address from the jsr call
 		PLA
 		PLX
 		;-- set up to print from there (ZPtr)
 		SETAX(ZPtr)
; skip over fisrt byte (end of jsr)
 		ZINC(ZPtr)
 		JSR 	PrStr 		; output up to null/term
 		;-- Calculate the return address
 		SEC 			; adjust one more
 		LDA 	ZPtr 		; lo
 		ADC 	ZTmp 		; + Len
 		STA 	ZPtr 		; -> lo
 		BCC 	_Print_X 	; carry?
 		INC 	ZPtr+1 		; yes, incr hi
_Print_X 	JMP 	(ZPtr) 		; jump to code after the in-line string

;----------------------------------------------- PrNL
PrNL: ; print CR,LF to CharOut
 		LDA 	#CR
 		JSR 	PrCh
 		LDA 	#LF
 		JMP 	PrCh

;----------------------------------------------- PrAXHex
PrAXHex: ; Print AX(lo/hi) as 4 hex digits [A]
 		PHA 			; save ZTmp
 		TXA 			; get high
 		JSR 	PrAHex 		; print hi as hex digits
 		PLA 			; restore ZTmp
 		;-- fall through to print ZTmp as hex digits
;----------------------------------------------- PrAHex
PrAHex: ; Print A as Hex digits (send/write) [A]
 		PHA 			;Save A for LSD
 		LSR 	a
 		LSR 	a
 		LSR 	a 		; MSD to LSD position
 		LSR 	a
 		JSR 	PrNib 		; Output hex digit
 		PLA 			; Restore A and then
 		;-- fall through to print hex routine
;----------------------------------------------- PrNib
PrNib: ; Convert hex nibble and Print it
 		PHX 			; save X
 		AND 	#$0F 		; Mask LSD for hex print
 		BR_NBCD(PrNibX) 	; non-bcd -> CvtHexX
 		;-- BCD so add 16 for second part of table
 		CLC
 		ADC 	#$10 		; add 16 for BCD part of table
PrNibX 		TAX
 		LDA 	Nib2HexTbl,X 	; Look Up
 		PLX
 		JMP 	PrCh 		; Write/Send

;----------------------------------------------- PrNum
PrNum: ; print NUMBER as digits to output (mem/io)
 		JSR 	CvtNum
 		LDAX(CVTBUF)
 		JMP 	PrStrAX

;----------------------------------------------- CvtNum
CvtNum: ; Convert NUMBER(24Bit) to digits in CVTBUF
 		LDX 	#7
 		LDA 	#0
 		STA 	CVTBUF,x
 		DEX
 		STA 	CVTBUF,x
 		DEX
CvtNumL 	;- num/10 remainder as digit
 		PHX 			; save output index
 		JSR 	NumD10 		; div NUMTMP by 10, remainder in A
 		PLX 			; recall index
 		ORA 	#'0' 		; convert remainder to a digit
 		STA 	CVTBUF,x 	; store the digit
 		DEX 			; back-up one pos to the left
 		BPL 	CvtNumL 	; loop until done
 		;-- Place sign in NR[0] based on SGN
; 		LDA 	#'+'
; 		LDY 	NA_SGN
; 		BPL 	CvtNumM
; 		LDA 	#'-'
;   CvtNumM 	STA 	CVTBUF 		; place sign at Res[0]
 		RTS
;----------------------------------------------- CvtNumD10
NumD10: ; NUMBER = NUMBER / 10 (24Bit), remainder in A [AXY]
; Divide value at NUMTMP  by 10, remainder in A [AY]
 		LDY 	#24 		; 24 bits
 		LDA 	#0
 		CLC
NumD10a 	ROL 	A
 		CMP 	#10
 		BCC 	NumD10b
 		SBC 	#10
NumD10b 	ROL 	NUMBER+0 	; L
 		ROL 	NUMBER+1 	; H
 		ROL 	NUMBER+2 	; U
 		DEY
 		BPL 	NumD10a
 		RTS
;----------------------------------------------- NumZero
NumZero: ; place zero into NUMBER (24Bit)
 		LDA 	#0 		; zero number
 		STA 	NUMBER
 		STA 	NUMBER+1
 		STA 	NUMBER+2
 		RTS

;----------------------------------------------- RdNum
RdNum: ;-- parse a number into NUMBER (24Bit) - destorys NUMTMP
 		JSR 	NumZero
RdNumL 		JSR 	IsDigit 	; messes with A
 		BCS 	RdNumX 		; no more digits
 		;-- LNNUM *= 10 (preserves AXY) - destroys NUMTMP
 		JSR 	NumM10
 		;-- digit value into NUMBER
 		AND 	#$0F
 		CLC
 		ADC 	NUMBER
 		STA 	NUMBER
 		BCC 	RdNumAX
 		INC 	NUMBER+1
 		BCC 	RdNumAX
 		INC 	NUMBER+2
RdNumAX 	JSR 	RdCh 		; next character
 		BRA 	RdNumL
RdNumX
 		ZCPY4($4C,NUMBER)
 		RTS

;----------------------------------------------- NumM10
NumM10: ; NUMBER = NUMBER * 10 (24Bit) - preserves AXY, destorys NUMTMP
 		PHA
 		ZCPY3(NUMTMP,NUMBER) 	; TMP = NUMBER
 		ZSL3(NUMBER) 		; NUMBER * 2
 		ZSL3(NUMBER) 		; NUMBER * 4
 		ZADD3(NUMBER,NUMTMP) 	; TMP = NUMBER *5
 		ZSL3(NUMBER) 		; NUMBER = NUMBER * 10
 		PLA
 		RTS

;----------------------------------------------- Hex2Nib
Hex2Nib: ; '0..9A..F' -> to nibble in A (C=1:Valid) [A]
 		EOR 	#'0' 		; Map digits to 0-9
 		CMP 	#9+1 		; Is it a decimal digit?
 		BCC 	Hex2Nib9 	; Yes!
 		ADC 	#$08 		; Map letter "A"-"F" to $FA-FF
 		CMP 	#$7A 		; Hex letter?
 		BCC 	Hex2Nib_X 	; No! Character not hex
Hex2Nib9 	SEC 			; set carry flag to indicate valid
Hex2Nib_X 	AND 	#$0F
 		RTS 			; carry clear if invalid char

.echo $-_ChrStr
.echo " Bytes in _ChrStr\n"

.LIST
 		;-- End of ChrStr

