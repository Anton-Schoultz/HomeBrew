;=================================================================== CHRSTR ===========
;*  ChrCopy             Output characters from input (mem/device) to output(Mem/device)
;*  ChrIn               Read character from input device (KBD,COM..) -> CHRGOT
;*  ChrInit             Copy ZPg code, Vectors, Init print flags, Wr to STRBUF
;*  ChrOut              Send character to output device (SCR,COM..)
;*  ChrWr               Write Character  A -> (ZWr++) , 00->(ZWr)
;*  Input               Read from Mem/IO and place in INBUF, until CR
;*  InputIO             Input INBUF from IO
;*  InputIOEcho         Input INBUF from IO, echo chars to IO
;*  PrCh                Print character - Write/Send as per flag
;*  PrNL                print CR,LF to CharOut
;*  PrStr               Print string pointed to by ZPtr [A]
;*  PrStrAX             Print string at AX [A]
;*  PrStrBuf            Print STRBUF [A]
;*  PrTerm              write terminating null
;*  RdCh                read character from memory or input device -> A, CHRGOT
;*  _Print_             Print in-line string
;*m BR_NBCD(tgt)        Branch to tgt if BCD=0
;*m BR_ND7(tgt)         Branch to tgt if MRK=0 (end with bit 7)
;*m BR_NRD(tgt)         Branch to tgt if Read=0
;*m BR_NWR(tgt)         Branch to tgt if Write=0
;*m PRINT(str)          Print in-line string
;*m PRINTLN(str)        Print in-line string with CR,LF
;*m PR_ALL()            Term Null F5=0 Term null only
;*m PR_ASCII()          Term Non-ASCII F5=1 Non-ASCII term
;*m PR_BCD_OFF()        HEX out  F4=0 HEX 0-9ABCDEF
;*m PR_BCD_ON()         BCD out  F4=1 BCD 0-9+-e.E
;*m PR_ECHO_OFF()       No Echo  F3=0
;*m PR_ECHO_ON()        ECHO the input F3=1 -> Chr
;*m PR_NECHO(tgt)       Branch to tgt if ECHO=0
;*m PR_RD_IO()          Read IO  F6=0 ChrIn
;*m PR_RD_MEM()         Read memory F6=1 ChrRd
;*m PR_WR_IO()          Write IO F7=0 ChrOut
;*m PR_WR_MEM()         Write memory F7=1 ChrWr
;*
#ifdef hide
.NOLIST
#endif
; ZPrFlg = Flag controls
 		;-- 0		1
; Bit7 PrCh	ChrOut 	IO	ChrWr MEM
; Bit6 RdCh	ChrIn  	IO	ChrRd MEM
; Bit5 Term	NULL 		Non-ASCII term
; Bit4 BCD	'0..9ABCDEF'	'0..9+-e.E '
; Bit3 Echo     No		Yes->PrCh
; Bit2
; Bit1
; Bit0

;----------------------------------------------- 7:Wr/Out
; BR_WR(tgt) Branch to tgt if Write=1
#define BR_WR(tgt) 	BBS7 ZPrFlg,tgt

; BR_NWR(tgt)	Branch to tgt if Write=0
#define BR_NWR(tgt) 	BBR7 ZPrFlg,tgt

; PR_WR_MEM()	Write memory	F7=1 ChrWr
#define PR_WR_MEM()	SMB7 ZPrFlg

; PR_WR_IO()	Write IO	F7=0 ChrOut
#define PR_WR_IO()	RMB7 ZPrFlg

;----------------------------------------------- 6:Rd/In
; BR_RD(tgt) Branch to tgt if Read=1
#define BR_RD(tgt) 	BBS6 ZPrFlg,tgt

; BR_NRD(tgt)	Branch to tgt if Read=0
#define BR_NRD(tgt) 	BBR6 ZPrFlg,tgt

; PR_RD_MEM()	Read memory	F6=1 ChrRd
#define PR_RD_MEM()	SMB6 ZPrFlg

; PR_RD_IO()	Read IO		F6=0 ChrIn
#define PR_RD_IO()	RMB6 ZPrFlg

;----------------------------------------------- 5:NonASCII
; BR_D7(tgt)	Branch to tgt if MRK=1 (end with bit 7)
#define BR_D7(tgt) 	BBS5 ZPrFlg,tgt
; BR_ND7(tgt)	Branch to tgt if MRK=0 (end with bit 7)
#define BR_ND7(tgt) 	BBR5 ZPrFlg,tgt

; PR_ASCII()	Term Non-ASCII	F5=1 Non-ASCII term
#define PR_ASCII()	SMB5 ZPrFlg

; PR_ALL()	Term Null	F5=0 Term null only
#define PR_ALL()	RMB5 ZPrFlg

;----------------------------------------------- 4:BCD HEX
; BR_BCD(tgt)	Branch to tgt if BCD=1
#define BR_BCD(tgt) 	BBS4 ZPrFlg,tgt
; BR_NBCD(tgt)	Branch to tgt if BCD=0
#define BR_NBCD(tgt) 	BBR4 ZPrFlg,tgt

; PR_BCD_ON()	BCD out		F4=1 BCD 0-9+-e.E
#define PR_BCD_ON()	SMB4 ZPrFlg

; PR_BCD_OFF()	HEX out		F4=0 HEX 0-9ABCDEF
#define PR_BCD_OFF()	RMB4 ZPrFlg

;----------------------------------------------- 3:Echo
; PR_ECHO(tgt)	Branch to tgt if ECHO=1
#define BR_ECHO(tgt) 	BBS3 ZPrFlg,tgt
; PR_NECHO(tgt)	Branch to tgt if ECHO=0
#define BR_NECHO(tgt) 	BBR3 ZPrFlg,tgt
; PR_ECHO_ON()	ECHO the input	F3=1 -> Chr
#define PR_ECHO_ON()	SMB3 ZPrFlg
; PR_ECHO_OFF()	No Echo		F3=0
#define PR_ECHO_OFF()	RMB3 ZPrFlg


; PRINT(str) 	Print in-line string
#define PRINT(str) 	jsr _Print_ \ .db "str",0

; PRINTLN(str) 	Print in-line string with CR,LF
#define PRINTLN(str) 	PRINT(str) \ jsr PrNL
 		;--
ChrRd 		= $0000 		; increment pointer and fetch, save in CHRGOT
ZRd 		= $07 			; points to character just fetched
CHRGOT 		= $0C 			; most recently fetched character
HLTFLG 		= $0D 			; halt flag 00=run (error code)
ZWr 		= $0E 			; address for ChrWr to write to

_ChrStr 	= $
;----------------------------------------------- ChrNext
; increment the ZRd pointer (inside the lda) and then fetch the character
RChrRd 		ZINC(ZRd) 		; 0001 0203 0405
 		lda 	$1234 		; 060708
 		sta 	CHRGOT 		; 090A
 		rts 			; 0B

.db $0 					; 0C = CHRGOT
.db $0 					; OD = Halt
.db 0,0 				; 0E0F = ZWr

; Initial values for 8 vectors in here, copied along with the above to zero page
 		;--
.dw ConIn 				; VCHRIN
.dw ConOut 				; VCHROUT
.dw $ABCD
.dw $ABCD
 		;--
.dw $ABCD
.dw $ABCD
.dw $ABCD
.dw $ABCD

;----------------------------------------------- CharInit
ChrInit: ; Copy ZPg code, Vectors, Init print flags, Wr to STRBUF
 		ldx 	#0
ChrInitL 	lda 	RChrRd,X
 		sta 	$00,X
 		inx
 		cpx 	#$20 		; 16 code, 8 x vectors
 		bne 	ChrInitL
 		;-- reset control flags
 		ZZERO(ZPrFlg) 		; reset flags ChrOut, Hex, NullTerm
 		;-- point writing to STRBUF
 		ZSET(ZWr,STRBUF)
 		rts


;----------------------------------------------- PrTerm
PrTerm: ; write terminating null
 		lda 	#0
;----------------------------------------------- PrCh
PrCh: ; Print character - Write/Send as per flag
 		;-- don't send null
 		cmp 	#0
 		beq 	ChrWrX
 		;-- outp[ut or memory
 		BR_WR(ChrWr) 		;wr=1?
 		;-- 0=fall through to send via ChrOut
;----------------------------------------------- ChrOut
ChrOut: ; Send character to output device (SCR,COM..)
 		jmp 	(VCHROUT)
;----------------------------------------------- ChrWr
ChrWr: ; Write Character  A -> (ZWr++) , 00->(ZWr)
 		sta 	(ZWr)
 		;-- bump to next address
 		ZINC(ZWr)
 		;-- ensure terminating null
 		lda 	#0
 		sta 	(ZWr)
ChrWrX 		rts

;----------------------------------------------- RdCh
RdCh: ; read character from memory or input device -> A, CHRGOT
 		BR_NECHO(RdCh1) 	; if echo is off, just go get the char
 		jsr 	RdCh1 		; fetch char
 		beq 	RdChX 		; Null? ->exit (no echo)
 		pha 			; save it
 		jsr 	ChrOut 		; echo to IO out
 		pla 			; restore
RdChX 		rts 			; return
; 1:ChrRd(mem) 0:ChrIn(IO)
RdCh1 		BR_NRD(ChrIn) 		;Rd=1? ChrRd
 		jmp 	ChrRd 		;ChrRd is code in Z Page, saves in CHRGOT

;----------------------------------------------- ChrIn
ChrIn: ; Read character from input device (KBD,COM..) -> CHRGOT
 		jsr 	ChrInV
 		sta 	CHRGOT
 		rts
ChrInV 		jmp 	(VCHRIN)
;----------------------------------------------- ChrRd
;ChrRd is code in Z Page

;----------------------------------------------- ChrCopy
ChrCopy: ; Output characters from input (mem/device) to output(Mem/device)
 		jsr 	RdCh 		; get from Mem / IO
 		beq 	ChrCopyX 	; Null -> exit
 		BR_ND7(ChrCopy2) 	; BREAK=Off, skip bit test
 		bmi 	ChrCopyX 	; bit 7 set -> exit
 		and 	#$7F 		; force ascii
ChrCopy2 	jsr 	PrCh 		; put Mem / IO
 		bra 	ChrCopy 	; loop
ChrCopyX 	rts

;----------------------------------------------- InputIOEcho
InputIOEcho: ; Input INBUF from IO, echo chars to IO
 		PR_WR_IO()
 		PR_ECHO_ON()
;----------------------------------------------- InputIO
InputIO: ; Input INBUF from IO
 		PR_RD_IO() 		; Read from IO
;----------------------------------------------- Input
Input: ; Read from Mem/IO and place in INBUF, until CR
 		ldx 	#0
 		txa
 		sta 	INBUF,x
InputL:  	jsr 	RdCh 		; get char from mem/io
; 		LDA 	CHRGOT
 		beq 	InputL
 		;-- ignore LF
 		cmp 	#LF
 		beq 	InputL
 		;-- exit on CR
 		cmp 	#CR
 		beq 	InputX
 		;-- back-space
 		cmp 	#BS
 		bne 	Input1
 		;-- back & null
 		tay 			; save BS char
 		lda 	#0 		; null
 		sta 	INBUF,x 	; place in buf
 		dex 			; back-up a position

 		sta 	INBUF,x 	; place in buf
 		tya
Input1 		sta 	INBUF,x 	; place in buf
 		;-- check buffer full
 		cpx 	#BUFSZ
 		bpl 	InputX 		; full -> exit
 		;-- move on
 		inx
 		bra 	InputL
InputX 		lda 	#0 		; terminate with a null
 		sta 	INBUF,X
 		sta 	INBUF+1,X
 		rts


;----------------------------------------------- PrStrBuf
PrStrBuf: ; Print STRBUF [A]
 		LDAX(STRBUF)
;----------------------------------------------- PrStrAX
PrStrAX: ; Print string at AX [A]
 		SETAX(ZPtr)
;----------------------------------------------- PrStr
PrStr: ; Print string pointed to by ZPtr [A]
; last index saved into ZTmp
 		phy
 		ldy 	#0
PrStr1 		lda 	(ZPtr),y
 		beq 	PrStrX 		; zero -> exit
 		;-- end of bit 7=1 ?
 		BR_ND7(PrStr2) 		; BREAK=Off, skip bit test
 		bmi 	PrStrX 		; bit 7 set -> exit
 		and 	#$7F 		; force ascii
 		;--
PrStr2 		jsr 	PrCh 		; print character
 		iny 			; move to next char
 		bne 	PrStr1 		; loop back (no more than 255 chars)
PrStrX 		sty 	ZTmp
 		ply 			; restore Y
 		rts 			; exit

;----------------------------------------------- _Print_
; PSEUDO-CODE
_Print_: ;Print in-line string
 		;-- pop the return address from the jsr call
 		pla
 		plx
 		;-- set up to print from there (ZPtr)
 		SETAX(ZPtr)
; skip over fisrt byte (end of jsr)
 		ZINC(ZPtr)
 		jsr 	PrStr 		; output up to null/term
 		;-- Calculate the return address
 		sec 			; adjust one more
 		lda 	ZPtr 		; lo
 		adc 	ZTmp 		; + Len
 		sta 	ZPtr 		; -> lo
 		bcc 	_Print_X 	; carry?
 		inc 	ZPtr+1 		; yes, incr hi
_Print_X 	jmp 	(ZPtr) 		; jump to code after the in-line string

;----------------------------------------------- PrNL
PrNL: ; print CR,LF to CharOut
 		lda 	#CR
 		jsr 	PrCh
 		lda 	#LF
 		jmp 	PrCh


.echo $-_ChrStr
.echo " Bytes in _ChrStr\n"

.LIST 					;-- End of ChrStr

