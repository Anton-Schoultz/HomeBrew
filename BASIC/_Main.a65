; #define hide

; E000-FFFF = 8k
#define _ROM $E000

; .echo "ROM at $F000-$FFFF (4k)\r"
.echo "ROM at $E000-$FFFF (8k)\r"
; .echo "ROM at $C000-$FFFF (16k)\r"

#include "Constants.a65"

#include "Macros.a65"
#include "_Vars.a65"

;=================================================================== MAIN =============
;*  CopyLine             copy TestSrc into INBUF
;*  Main                 MAIN code
;*  Reset                Reset (Cold start)
;*  Warm                 Warm Start entry point
;*
#ifdef hide
; .NOLIST
#endif

.org _ROM
.LIST
;----------------------------------------------- START OF ROM
; 		START OF ROM
 		jmp 	Reset

.db DATE
.db TIME

#include "ConSim.a65" 			; Console Implementation
#include "ChrStr.a65" 			; Base IO (incl macros)
#include "Util.a65" 			; utilities for general use
#include "Error.a65" 			; Error/token expansion

#include "Str.a65" 			; String code

#include "Math.a65" 			; Number code
#include "Eval.a65" 			; Evaluator


TestSrc
.DB "10  PRINT 12/(3+2"	;  2.4 ok
; .DB "10  PRINT 12/10+120"	;  1.212e02 =  121.2 ok
; .DB "10  PRINT 120+12/10"	;  1.212e02 =  121.2 ok
; .DB "10  PRINT 12/10-120"	; -1.188e02 = -118.8 ok
; .DB "10  PRINT 120-12/10"     ;  1.188e02 =  118.8 ok

; .db "10 PRINT 1234/1000"	;  1.234 ok
; .db "10 PRINT 1234"

; .db "10 PRINT 12345+1234/1000"	; 4.433450e3 = 4433.45 FAIL 12346.234

 		;-- .DB "10 PRINT 12/5"

 		;-- .db QT,"xyz",QT
 		;-- .db ",123"
.db 0


Str1234 	.DB 	"1234",0
StrNeg123 	.DB 	"-12",0

 		;-- .DB "PRINT 1234,456,9,"
 		;-- .db QT,"Hi",QT
 		;-- .db " 					;12"
 		;-- .db 0

 		;-- 0123456789a
Text 		.DB 	"  Hello  1234  ",0
Text1 		.DB 	" - Happy days",0

;----------------------------------------------- Reset
Reset: ;Reset (Cold start)
 		sei 			; Halt IRQs
 		ldx 	#$ff 		; Set Stack pointer
 		txs
 		cld 			; Binary mode
; RAMBEG    BASBEG          BASEND      VAREND        STREND  ARYBEG  RAMEND
;   | A-Z Vars | Program lines | Variables | String work | Free | Arrays |  blank | ROM
 		LDAX($800)
 		SETAX(RAMBEG)
 		LDAX($8000) 		; end of 32K RAM
 		SETAX(RAMEND)

 		jsr 	EdtNew 		; NEW

;----------------------------------------------- Warm
Warm: ;Warm Start entry point
 		;-- Copy ZPage Code
 		jsr 	ChrInit 	; set up mem rd
 		jsr 	NumInit 	; init calc stack pointer

;----------------------------------------------- Main
Main: ; MAIN code
 		CLS()

MainLoop 	;-- Prompt and input

 		PR_WR_IO()
; 		jsr 	PrNL
; 		lda 	#'>'
; 		jsr 	ConOut
; 		jsr 	InputIOEcho 	; Read from Mem/IO and place in INBUF, until CR
 		;--
 		jsr 	CopyLine
 		;--
 		;-- clear screen
 		CLS()
 		;--
 		;-- display input text
 		LDAX(INBUF)
 		jsr 	PrStrAX 	; display source line
 		jsr 	PrNL
 		;--
;   parse input
;     length is placed into ZCnt
;     Line no is placed into LN_FIND
 		jsr 	Parse 		; Parse INBUF into TOKBUF

 		PR_WR_IO()
 		;-- dump TOKBUF
 		HEX_DUMP(TOKBUF) 	; dump 8
 		jsr 	HexDump 	; dump next 8
 		jsr 	HexDump 	; dump next 8
 		jsr 	HexDump 	; dump next 8
 		jsr 	PrNL

 		HEX_DUMP(LN_NXT) 	; Line NXT,NUM, FIND
 		HEX_DUMP(ZSrc)
 		jsr 	PrNL

 		jsr 	EdtUpd

 		;--
 		PR_ZSUP_ON()
 		;-- List the line in TOKBUF
 		jsr 	List
; 		;--
; 		;-- ; 		PR_ZSPC_OFF()
 		;--
; 		lda 	TOKBUF
; 		cmp 	#T_LineNo
; 		beq 	MainLoop
 		;--
; 		;-- LineNo=zero will execute
 		;--
 		;-- Run
 		lda 	#':'
 		jsr 	PutChr
 		PR_ZSPC_ON()
 		jsr 	Run

 		;-- loop back and do it again
; 		bra 	MainLoop

 		HALT()

;----------------------------------------------- CopyLine
CopyLine: ; copy TestSrc into INBUF
 		;-- Copy test source into INBUF
 		ldy 	#$FF
CopyLineL 	iny
 		lda 	TestSrc,y
 		sta 	INBUF,y
 		cmp 	#0
 		bne 	CopyLineL
 		rts

#include "Variables.a65" 		; Variable parse/list

#include "All.a65" 			; include all keywords
#include "Tok.a65" 			; Genral Parse/List
#include "Editor.a65" 			; Program editor

#include "IrqNmi.a65" 			; Interrupt handlers

ROMEND 		= $


;----------------------------------------------- TblKeyword
; Include for the keyword table ..
.org TblKeyword
#include "All.a65"

;----------------------------------------------- TblRun
; Include for the jump/run table
.org TblRun
.nolist
#include "All.a65"
T_Max 		= LOW($)+$80
#if T_Max > $F0
.echo "Too many tokens\r"
#endif

.dw 0
.list


;----------------------------------------------- hardware vectors
; FFFA,B	NMI
; FFFC,D	Reset
; FFFE,F	IRQ
.org $FFFA
.dw Nmi 				; FFFA,B=> NMI		Points to Non-Maskable Interrupt handler
.dw Reset 				; FFFC,D=> NRET	Points to Reset address (cold start)
.dw Irq 				; FFFE,F=> IRQ		Points to Interrupt handler

.echo "\nEPROM "
.echo ROMEND - _ROM + 512
.echo " bytes used (~"
.echo (ROMEND - _ROM + 512) * 100 / 8192
.echo "%)  "
.echo ($FF00 - ROMEND)
.echo " bytes remaining.\n\n"


.end
