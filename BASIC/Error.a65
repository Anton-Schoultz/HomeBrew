#ifdef hide 				; Error
.NOLIST
#endif

#if (($/256)>=PG_ROM) & (($/256)<PG_KEY)

#define ERROR(n) ldx #n\ jmp Error


;=================================================================== ERROR ============
; NOTE: Message nos go up in 2s
;
;*  ErrList              List offending line (if available)
;*  Error                Hanlde error[X] resetting to warm start
;*  Msg                  Display Message (ZPtr)[X] A @/! Y #/& Char/hex *CallAddr
;*  MsgChr               print char in .A if it is ascii, otherwise a '?'
;*  RegLoad              Load registers from ZReg~
;*  RegSave              Save registers into ZReg~
;*
_Err 		= $

; NOTE: Message nos go up in 2s
#define ERR_OK 		0
#define ERR_EXPECTED 	2
#define ERR_CONST 	4
#define ERR_GOSUB 	6
#define ERR_FOR 	8
#define ERR_VAR 	10
#define ERR_BADVAR 	12
#define ERR_DIV0 	14
#define ERR_REDIM 	16
#define ERR_MEMORY 	18
#define ERR_TOKEN 	20
#define ERR_SYNTAX 	22
#define ERR_RANGE 	24
#define ERR_UNDEFSTR 	26

#define DOT '.'+$80

; @	A as character
; !	A as hex
; #	Y as char
; $	Y as hex
; % 	Y as decimal

ErrTbl
.DB "OK",DOT 				; 0=ERR_OK
.DB "Expected '@':! but got '#':& *",DOT ; 2=ERR_EXPECTED
.DB "Expected constant",DOT 		; 4=ERR_CONST
.DB "GOSUB/RETURN",DOT 			; 6=ERR_GOSUB
.DB "FOR/NEXT",DOT 			; 8=ERR_FOR
.DB "Expected variable",DOT 		;10=ERR_VAR
.DB "Invalid variable !",DOT 		;12=ERR_BADVAR
.DB "Divide by zero",DOT 		;14=ERR_DIV0
.DB "Redimension",DOT 			;16=ERR_REDIM
.DB "Out of memory",DOT 		;18=ERR_MEMORY
.DB "Invalid token !",DOT 		;20=ERR_TOKEN
.DB "Syntax",DOT 			;22=ERR_SYNTAX
.DB "Out of Range",DOT			;24=ERR_RANGE
.DB "Undefined string",DOT		;26=ERR_UNDEFSTR
.DB 0



;----------------------------------------------- X_Err
Error: ; Hanlde error[X] resetting to warm start
 		pha
 		phx
 		phy
 		jsr 	ErrList
 		ZSET(ZPtr,ErrTbl) 	; point to the keyword table
 		jsr 	PrNL
 		ply
 		plx
 		pla
 		;-- Display Message (ZPtr)[X] A:@/! Y:#/% Char/hex
 		jsr 	Msg
 		jsr 	PrNL

ErrorX 		jmp 	Main

ErrList: ; List offending line (if available)
 		;-- check if command line
 		lda 	LN_NUM
 		ora 	LN_NUM+1
 		bne 	ErrList1
 		rts
 		;-- from program, so set up the offending line
ErrList1 	clc
 		lda 	#3
 		adc 	LN_ADR
 		sta 	ZRd
 		lda 	#0
 		adc 	LN_ADR+1
 		sta 	ZRd+1
 		;-- and list it
 		jmp 	ListLn


; == Special characters == DO NOT USE $ as it is part of String Keywords
; @	A as character
; !	A as hex
; #	Y as char
; &	Y as hex
; % 	Y as decimal
; * 	Address where error was called from


;----------------------------------------------- RegLoad
RegLoad: ; Load registers from ZReg~
 		LDA 	ZRegP
 		pha
 		lda 	ZRegA 		; load .A
 		ldy 	ZRegY 		; load .Y
 		ldx 	ZRegX 		; load .X
 		plp
 		rts

;----------------------------------------------- RegSave
RegSave: ; Save registers into ZReg~
 		sta 	ZRegA 		; save .A
 		sty 	ZRegY 		; save .Y
 		stx 	ZRegX 		; save .X
 		;-- status register
 		php
 		pla
 		STA 	ZRegP
 		rts

#define ZTokPtr ZPtr
;----------------------------------------------- Msg
Msg: ;  Display Message (ZPtr)[X] A @/! Y #/& Char/hex *CallAddr
 		jsr 	RegSave 	; save regs
 		ldy 	#0 		; in case X=0
 		txa
 		and 	#$7F
 		lsr 	a 		; A = TokNo / 2
 		tax 			; index in table
; 		cpx 	#0
 		beq 	MsgL0 		; token 80 is special ;P
 		ldy 	#$FF
 		;--
 		;-- MsgNxt 		cpx 	#0 		; no more
; 		beq 	MsgX
 		;-- move to next word
MsgNxtL 	iny
 		lda 	(ZTokPtr),y
 		beq 	MsgInvalid 	; end of list, not found
 		bpl 	MsgNxtL
 		;-- got the marker
 		dex
 		bne 	MsgNxtL
MsgL 		;-- found the start of the word
 		iny 			; skip over the last end-of-word marker
MsgL0 		;-- output the word
 		lda 	(ZTokPtr),y
 		beq 	MsgX 		; end of list -> done
 		bmi 	MsgLX 		; last char
 		BR_AEQ('@',MsgAC) 	; ZRegA as character
 		BR_AEQ('!',MsgAH) 	; ZRegA as hex
 		BR_AEQ('#',MsgYC) 	; ZRegY as character
 		BR_AEQ('&',MsgYH) 	; ZRegY as hex
 		BR_AEQ('%',MsgYD) 	; ZRegY as dec
 		BR_AEQ('*',MsgErrAdr) 	; caller address stack
 		jsr 	PutChr 		; echo
 		bra 	MsgL 		; loop next char

MsgLX 		;-- last character of the word (marked one)
 		and 	#$7F 		; mask off bit7
 		jsr 	PutChr 		; output it and return
 		jsr 	IsAlpha
 		BR_F(MsgX) 		; ends in alpha?
 		lda 	#' ' 		; yes, pad a blank
 		jsr 	PutChr
MsgX 		;jsr ChrRd
 		RTN_T() 		; otherwise done
MsgInvalid 	; not found
 		RTN_F() 		; return false
MsgAC 		lda 	ZRegA 		; '@' A as char
 		jsr 	MsgChr
 		bra 	MsgL
MsgAH 		lda 	ZRegA 		; '!' A as hex
 		bra 	MsgHex

MsgYC 		lda 	ZRegY 		; '#' Y as char
 		jsr 	MsgChr
 		bra 	MsgL
MsgYH 		lda 	ZRegY 		; '$' Y as hex
MsgHex 		pha
 		lda 	#'$'
 		jsr 	PutChr
 		pla
 		jsr 	PrAHex
 		bra 	MsgL
MsgYD 		lda 	ZRegY
MsgDec 		jmp 	PrADec3

MsgErrAdr 	;-- display stack trace
 		jsr 	PrNL
 		;-- drop the call from error
 		pla
 		pla
 		lda 	ZRd
 		STA 	ZTmp
 		lda 	ZRd+1
 		STA 	ZTmp+1
 		;-- trace to depth of 8
 		ldx 	#5
 		BRA 	MsgStkL1
MsgStkL 	;-- display stack trace
 		lda 	#'<'
 		jsr 	PutChr
 		lda 	#'~'
 		jsr 	PutChr
 		;-- pop Hi,Lo and decr to match the jsr address
 		pla
 		STA 	ZTmp
 		pla
 		STA 	ZTmp+1
 		ZDEC(ZTmp)
 		ZDEC(ZTmp)
 		;-- print address in hex
MsgStkL1 	LDA 	ZTmp+1
 		jsr 	PrAHex
 		LDA 	ZTmp
 		jsr 	PrAHex
 		;-- loop
 		dex
 		BNE 	MsgStkL
 		;-- done, so warm start
 		jsr 	PrNL
 		jmp 	Main

MsgChr: ; print char in .A if it is ascii, otherwise a '?'
 		cmp 	#$7E
 		bpl 	MsgChrNo
 		cmp 	#$21
 		bpl 	MsgChrX
MsgChrNo 	lda 	#'?'
MsgChrX 	jmp 	PutChr




.echo "  _Error\t"
.echo $-_Err
.echo "\n"
.list
#endif
