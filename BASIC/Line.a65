.LIST
#ifdef hide
.NOLIST
#endif
;=================================================================== LINE =============
;*  LnComp               Compare line number to LN_FND
;*  LnNext               Start the next line
;*  LnSeek               Search forward for LN_FND
;*  LnSeekTop            search for LN_FND from top of program
;*  LnTop                Sets address of next line to top ( BASBEG->LN_NXT) and does LnNext
;*

_Ln 		= $

; $0034  Int(LN_NUM) 	; Current Line number
; $0036  Int(LN_ADR) 	; Current Line address
; $0038  Int(LN_NXT) 	; Adress of next line
; $003A  Int(LN_LEN) 	; length of tokenised line in TOKBUF (for editor)

; $003C  Int(LN_FND)   ; Line number to look for

;----------------------------------------------- LnTop
LnTop: ; Sets address of next line to top ( BASBEG->LN_NXT) and does LnNext
 		ZCPY(LN_NXT,BASBEG)

;----------------------------------------------- LnNext
LnNext: ; Start the next line
; LN_NXT -> ZRd -> LN_ADR
; Process the T_LineNo, sets LN_ADR,LN_NUM,LN_LEN and LN_NXT
; fetch first byte after the lineNo token
 		ZCPY(ZRd,LN_NXT) 	; point ChrGet to the line
 		ZCPY(LN_ADR,ZRd) 	; save start of this line
 		;-- zero length
 		lda 	#0
 		sta 	LN_LEN
 		sta 	LN_LEN+1
 		;-- check that it points to a line
 		lda 	(ZRd)
 		beq 	LnEOF
 		cmp 	#T_LineNo
 		beq 	LnNextRd
 		lda 	#0 		; return null for error
LnEOF 		rts 			; return EQ=1
 		;-- fetch the line no -> LN_NUM
LnNextRd 	jsr 	ChrRd 		; get lo no
 		sta 	LN_NUM
 		jsr 	ChrRd 		; hi num
 		sta 	LN_NUM+1
 		;-- get length of line and address of next line
 		jsr 	ChrRd
 		sta 	LN_LEN
 		clc
 		adc 	ZRd
 		sta 	LN_NXT
 		lda 	#0
 		sta 	LN_LEN+1
 		adc 	ZRd+1
 		sta 	LN_NXT+1
 		;-- fetch the first byte of line
 		jmp 	ChrRd 		; read next byte->CHRGOT


;----------------------------------------------- LnComp
LnComp: ; Compare line number to LN_FND
; NUM < FIND  N:1 Z:0 C:0	mi => continue search
; NUM = FIND  N:0 Z:1 C:1	eq => match
; NUM > FIND  N:0 Z:0 C:1	missing / insert
 		lda 	LN_NUM+1
 		cmp 	LN_FND+1
 		bne 	LnCompX
 		;-- high byte is eq so test low byte
 		lda 	LN_NUM
 		cmp 	LN_FND
LnCompX 	rts

;----------------------------------------------- LnSeekTop
LnSeekTop: ; search for LN_FND from top of program
 		;-- top of code & read line
 		jsr 	LnTop
 		beq	LnSeekEOF
;----------------------------------------------- LnSeek
LnSeek: ; Search forward for LN_FND
 		jsr 	LnComp 		; mi=Cont, eq=Match ne=ins
 		bpl 	LnSeekX 	; eq=match, c:1=ins
 		;-- Not there yet, next line
LnSeekNxt 	jsr 	LnNext 		; move to next line
 		BNE 	LnSeek
 		;-- EOF or not T_LineNo
LnSeekEOF	lda 	#$FF 		; sets Minus for EOF/Error
LnSeekX 	rts
; N:1 	  MI => EOF/Error
; N:0 Z:1 EQ => NUM=FIND Match
; N:0 Z:0 NE => NUM>FIND

.echo "  _Line\t\t"
.echo $-_Ln
.echo "\n"
.list

