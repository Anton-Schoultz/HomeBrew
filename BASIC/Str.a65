;=================================================================== STR =============
; String functions
;
;*  EvIsStr              Return EQ if the token in A is a string value
;*  EvString             Evuate a string expression -> STRBUF
;*  StrAdd               Append top two strings
;*  StrAddNum            Append the converted numeric (in NUM_BUF) to the string
;*  StrDBug              debug editor values
;*  StrGet               get string at index A  A$..Z$ 1..26
;*  StrInit              Initialise string buffer
;*  StrLit               Recall a string literal
;*  StrLower             convert to LOWER case
;*  StrOut               Output the resulting string (cut at 255)
;*  StrOvr               Overflow - truncate
;*  StrPush              Push temp string sets up S_PTR_A,S_LEN_A
;*  StrSet               Store string at index A  A$..Z$ 1..26
;*  StrUpper             convert to UPPER case
;*m STROFF()             covert index in .A to an offset in .X based on size of pointer
;*
#ifdef hide
.NOLIST
#endif

; STRSZ			Size for STRBUF
; Int(ZStr) 		ZStr points to string result
; Short(ZStrLen)	Length of STRBUF used (write index)

;----------------------------------------------- String
; (Z) ->    LenL|LenH|Characters.....|00|
; Int(STR_PTR) 	; pointer to string
; Int(STR_END) 	; end of string work area
; Int(STR_LEN) 	; no of chars + 3 (1Null+2Len)

; RAMBEG
; BASBEG          BASEND      VAREND        STR_END  ARYBEG  RAMEND
;   |  Program lines | Variables | String work | Free | Arrays |  blank | ROM

; NUM_A has Sgn,Exp, A,B,C...

; re-use NUM_A A,B to point to the top most string
#define S_PTR_A NUM_AA
; re-use NUM_A S,X as the length
#define S_LEN_A NUM_AS

; re-use NUM_B A,B to point to the operand string
#define S_PTR_B NUM_BA
; re-use NUM_B S,X as the length of opperand
#define S_LEN_B NUM_BS

; STROFF()  covert index in .A to an offset in .X based on size of pointer
#define STROFF() asl a\ tax

_Str 		= $

; when storing a sting,
; if the variable's pointer is zero then
;    allocate a new space and set pointer
;    copy the data to the string space checking limit
; otherwise
;    copy data to it, checking limit
 		;--
; ZPtr must point to the memory block


;----------------------------------------------- StrGet
StrGet: ; get string at index A  A$..Z$ 1..26
 		STROFF()
 		lda 	VARSTR,X
 		sta 	ZPtr
 		lda 	VARSTR+1,X
 		sta 	ZPtr+1
 		ora 	ZPtr
 		bne 	StrLoad 	; string exists
 		;-- no string data yet
 		rts
StrLoad		jsr	StrPoint	; point and length in ZCnt
		ZCPY(ZSrc,ZTgt)		; from hi-mem
		ZCPY(ZTgt,S_PTR_A)
		ldy 	#0
		;- copy upto and including the null (not whole block)
StrLoadL 	lda	(ZSrc),y
 		sta 	(S_PTR_A),Y
 		beq 	StrLoadX 	; ending null
 		iny
 		bne 	StrLoadL 	; max out at 255
 		;-- overflow, so back up and null
 		jsr 	StrOvr
 		;-- fall through to save index
StrLoadX 	sty 	S_LEN_A
 		ZCPY(STR_LEN,S_LEN_A)
 		rts

;----------------------------------------------- StrSet
StrSet: ; Store string at index A  A$..Z$ 1..26
 		STROFF()
 		lda 	VARSTR,X
 		sta 	ZPtr
 		lda 	VARSTR+1,X
 		sta 	ZPtr+1
 		ora 	ZPtr
 		bne 	StrSave 	; string already exists

 		;-- no string yet, calc size to next 16
 		ZCPY(ZCnt,S_LEN_A) 	; length needed
 		jsr 	EdtAlloc 	; find/create space, overwrites Zptr

StrSave 	;- ZPtr points to the string space
		jsr	StrPoint
 		;-- Src = S_PTR_A
 		ZCPY(ZSrc,S_PTR_A)
 		;-- copy bytes
 		JSR 	EdtDwn
 		rts

StrPoint	;- ZPtr points to the string space
 		;-- get max size to copy (dim'd size)
 		ldy 	#0
 		lda 	(ZPtr),y
 		sta 	ZCnt
 		iny
 		lda 	(ZPtr),y
 		sta 	ZCnt+1
 		;-- tgt = Ptr + 2
 		ZCPY(ZTgt,ZPtr)
 		ZINC(ZTgt)
 		ZINC(ZTgt)
 		rts

;-----------------------------------------------
EvString: ; Evuate a string expression -> STRBUF
; return T=OK, F otherwise
; 		jsr 	StrClr 		; clear the result

 		;-- for now, just handle one item
EvStrL 		jsr 	EvStrItem
 		RTN_IFF()
 		;--
 		lda 	CHRGOT
 		cmp 	#'+'
 		bne 	EvStrX
 		jsr 	ChrRd 		; consume the '+'
 		bra 	EvStrL


EvStrX 		RTN_T()


EvStrItem 	; check the token
 		lda 	CHRGOT
 		;-- string Value ?
 		BR_AEQ(T_StrLit,StrLit)
 		;-- BR_AEQ(T_StrVar,RtnTrue)
 		;-- BR_AEQ(T_StrAry,RtnTrue)
 		RTN_F()


EvStrNxt 	;-- next token
 		jsr 	ChrRd
 		bne 	EvStrL
 		rts

;----------------------------------------------- EvIsStr
EvIsStr: ; Return EQ if the token in A is a string value
 		BR_AEQ(T_StrLit,EvIsStrX)
 		;-- BR_AEQ(T_StrVar,EvIsStrX)
 		;-- BR_AEQ(T_StrAry,EvIsStrX)
EvIsStrX 	rts

;======================================================================================

;----------------------------------------------- StrInit
StrInit: ;Initialise string buffer
 		ZCPY(STR_END,VAREND) 	; point to open area
 		ZSET(STR_LEN,0) 	; set length as zero
 		rts

;----------------------------------------------- StrPush
StrPush: ;Push temp string sets up S_PTR_A,S_LEN_A
 		jsr 	NumPushA
 		;--
 		ZADD(STR_END,STR_LEN)
 		ZCPY(S_PTR_A,STR_END) 	; set pointer
 		ZSET(STR_LEN,0) 	; set length as zero
 		ZSET(S_LEN_A,0) 	; zero length
 		rts

;----------------------------------------------- StrOvr
StrOvr: ; Overflow - truncate
 		dey 			; back up to last char
 		lda 	#0 		; make it null
 		sta 	(S_PTR_A),Y
StrEnd 		sty 	S_LEN_A
 		rts

;----------------------------------------------- StrLit
StrLit: ; Recall a string literal
; CHRGOT is T_StrLit, ChrRd will get the first character
 		jsr 	StrPush 	; create a temp space
 		ldy 	#0
 		sty 	S_LEN_A+1 	; clear high
StrLitL 	jsr 	ChrRd 		; read literal from code
 		sta 	(S_PTR_A),Y
 		beq 	StrLitX 	; ending null
 		iny
 		bne 	StrLitL 	; max out at 255
 		;-- overflow, so back up and null
 		jsr 	StrOvr
 		;-- fall through to save index
StrLitX 	sty 	S_LEN_A
 		ZCPY(STR_LEN,S_LEN_A)
 		rts


;----------------------------------------------- StrAdd
StrAdd: ; Append top two strings
; StrPush sets it up so that the second string is already in the right place
; so just swap data and adjust initial length to add second's length
 		jsr 	NumPopB
 		jsr 	NumSwap
 		ZADD(S_LEN_A,S_LEN_B) 	; adjust length of result
 		rts


;----------------------------------------------- StrOut
StrOut: ; Output the resulting string (cut at 255)
 		ldy 	#0
StrOutL 	lda 	(S_PTR_A),y
 		pha
 		jsr 	PutChr 		; A -> mem/io
 		pla
 		beq 	StrOutX 	; null -> done
 		iny
 		bne 	StrOutL
StrOutX 	rts

;----------------------------------------------- StrUpper
StrUpper: ; convert to UPPER case
 		ldy 	#$FF
StrUpper1 	iny
 		lda 	(S_PTR_A),Y
 		beq 	StrUpperX
 		BR_ALT('a',StrUpper1)
 		BR_AGE('{',StrUpper1)
 		and 	#$DF
 		sta 	(S_PTR_A),Y
 		bra 	StrUpper1
StrUpperX 	rts

;----------------------------------------------- StrLower
StrLower: ; convert to LOWER case
 		ldy 	#$FF
StrLower1 	iny
 		lda 	(S_PTR_A),Y
 		beq 	StrUpperX
 		BR_ALT('A',StrLower1)
 		BR_AGE('[',StrLower1)
 		ora 	#$20
 		sta 	(S_PTR_A),Y
 		bra 	StrLower1
StrLowerX 	rts


;======================================================================================

;----------------------------------------------- StrAddNum
StrAddNum: ; Append the converted numeric (in NUM_BUF) to the string
 		jsr 	StrPush 	; create a temp space
 		ldy 	#0
 		sty 	S_LEN_A+1 	; clear high
StrAddNumL 	lda 	NUM_BUF,Y
 		sta 	(S_PTR_A),y
 		beq 	StrAddNumX
 		iny
 		bne 	StrAddNumL
 		;-- overflow, so back up and null
 		jmp 	StrOvr
 		;-- fall through to save index
StrAddNumX 	sty 	S_LEN_A
 		ZCPY(STR_LEN,S_LEN_A)
 		rts



#if _DBUG
;----------------------------------------------- StrDBug
StrDBug: ; debug editor values
 		php
 		pha
 		phx
 		phy

 		PRINTLN("PtrA LenA PtrB LenB")
 		HEX_INT(S_PTR_A)
 		HEX_INT(S_LEN_A)
 		HEX_INT(S_PTR_B)
 		HEX_INT(S_LEN_B)
 		CRLF()

 		PRINTLN("VEND SEND SLEN")
 		HEX_INT(VAREND)
 		HEX_INT(STR_END)
 		HEX_INT(STR_LEN)
 		CRLF()

 		PAUSE()

 		ply
 		plx
 		pla
 		plp

 		rts



Hi:  		.DB 	T_StrLit,"HellO ",0
Big 		.DB 	T_StrLit,"BiG ",0
Wo:  		.DB 	T_StrLit,"WorlD.",0
;----------------------------------------------- StrTest
StrTest
 		jsr 	StrInit

 		ZSET(ZRd,Hi)
 		jsr 	StrLit

 		ZSET(ZRd,Big)
 		jsr 	StrLit
 		jsr 	StrUpper

 		ZSET(ZRd,Wo)
 		jsr 	StrLit
 		jsr 	StrLower

 		jsr 	StrAdd
 		jsr 	StrAdd

 		jsr 	StrOut

 		rts
#endif

 		;-- ;----------------------------------------------- StrSet
 		;-- StrSet: ; Copy String to the variable at (ZPtr)
; 		ldy 	#0
 		;-- StrSetL 	lda 	(ZStr),y
; 		sta 	(ZPtr),y
; 		beq 	StrSetX 	; null -> done
; 		iny
 		;--
; 		;-- need to check DIM size
 		;--
; 		bne 	StrSetL
; 		lda 	#0
; 		sta 	(ZStr),y
 		;-- StrSetX 	rts
 		;--

 		;-- ;----------------------------------------------- StrAdd
 		;-- StrAdd: ; Append string (ZStr) to STRBUF (Recall)
; 		ldy 	#0
; 		ldx 	ZStrLen
 		;-- StrAddL 	lda 	(ZStr),y
; 		sta 	STRBUF,X
; 		beq 	StrEnd 		; ending null
; 		;--
; 		iny
; 		inx
; 		cpx 	#STRSZ
; 		bne 	StrAddL 	; in size


 		;-- ;----------------------------------------------- StrClr
 		;-- StrClr: ; Clear STRBUF
; 		ldy 	#0
; 		tya
; 		sta 	ZStrLen
 		;-- StrClrL 	sta 	STRBUF,y
; 		iny
; 		cpy 	#STRSZ
; 		bne 	StrClrL
 		;-- StrRtn 		rts

 		;-- ;----------------------------------------------- StrAddChr
 		;-- StrAddChr: ; Add character .A to STRBUF
; 		ldx 	ZStrLen
; 		sta 	STRBUF,x
; 		inx
; 		lda 	#0
; 		sta 	STRBUF,x
; 		cpx 	#STRSZ
; 		bmi 	StrAddChrX
; 		;-- overflow, so back up and null
; 		;-- jmp 	StrOvr
 		;-- StrAddChrX 	stx 	ZStrLen
; 		rts

 		;-- ;----------------------------------------------- PrStrBuf
 		;-- PrStrBuf: ; Print STRBUF -> PutChr -> Mem/IO
; 		LDAX(STRBUF)
; 		jmp 	PrStrAX



 		;-- ;----------------------------------------------- StrTail
 		;-- StrTail: ; Keep from Y onwards
; 		;-- index is outof range so result is empty
; 		cpy 	#STRSZ
; 		bpl 	StrSubMT 	; could jmp to StrClr
; 		;-- index beyond end so result is empty
; 		cpy 	ZStrLen
; 		bpl 	StrSubMT 	; could jmp to StrClr
; 		;--
; 		ldx 	#0
 		;-- StrSubL 	lda 	STRBUF,y
; 		sta 	STRBUF,x
; 		beq 	StrEnd 		; save len & exit
; 		iny
; 		inx
; 		cpx 	#STRSZ
; 		bne 	StrSubL
; 		bra 	StrOvr 		; force stop at max
 		;--
 		;-- ;----------------------------------------------- StrSubMT
 		;-- StrSubMT: ;Make string empty
; 		lda 	#0
; 		sta 	STRBUF
; 		sta 	ZStrLen
; 		rts
 		;--
 		;-- ;----------------------------------------------- StrHead
 		;-- StrHead: ; Truncate STRBUF at Y
; 		;-- index is out of range - keep all
; 		cpy 	#STRSZ
; 		bpl 	StrHeadX 	; keep all
; 		;-- index beyond end - keep all
; 		cpy 	ZStrLen
; 		bpl 	StrHeadX 	; keep all
; 		;-- place the nul
; 		lda 	#0
; 		sta 	STRBUF,Y
; 		;-- save new index
; 		sty 	ZStrLen
 		;-- StrHeadX 	rts
 		;--
 		;-- ;----------------------------------------------- StrTrim
 		;-- StrTrim: ; trim leading and trailing blanks
; 		ldy 	#$FF
; 		ldx 	#0
 		;-- StrTrim1 	iny
; 		lda 	STRBUF,Y
; 		beq 	StrTrimX 	; null -> done
; 		cmp 	#' '
; 		beq 	StrTrim1 	; blank -> loop
 		;-- StrTrim2 	sta 	STRBUF,X 	; save char
; 		iny
; 		inx
; 		lda 	STRBUF,Y
; 		bne 	StrTrim2 	; copy up to null
; 		sta 	STRBUF,X 	; write the null
; 		dex
 		;-- StrTrim3 	;-- now trim trailing ' '
; 		lda 	STRBUF,X
; 		cmp 	#' '
; 		bne 	StrTrimX 	; non-space -> exit
; 		lda 	#0 		; null the space
; 		sta 	STRBUF,x
; 		dex
; 		bne 	StrTrim3
 		;-- StrTrimX 	rts
 		;--
 		;--
 		;--




.echo "  _Str\t\t"
.echo $-_Str
.echo "\n"
.list

