;=================================================================== STR =============
; String functions
;
;*  DB_Str               Debug String values - PtrA LenA PtrB LenB
;*  EvIsStr              Return EQ if A is T_StrLit,T_StrVar
;*  EvStrItem            get a single item T_StrLit |T_StrVar| StrFn
;*  EvString             Evuate a string expression -> STRBUF
;*  StrAddNum            Append the converted numeric (in NUM_BUF) to the string
;*  StrAppend            Append top two strings
;*  StrGet               get string at index A  A$..Z$ 1..26
;*  StrInit              Initialise string buffer
;*  StrLen               check length of Str_A, set in S_LEN_A
;*  StrLit               Recall a string literal
;*  StrLower             convert to LOWER case
;*  StrOut               Output the resulting string (cut at 255)
;*  StrOvr               Overflow - truncate
;*  StrPoint             (ZPtr)->Object, Exits (ZTgt)->data and ZCnt=Size
;*  StrPush              Push temp string sets up S_PTR_A,S_LEN_A
;*  StrSet               Store string at index A  A$..Z$ 1..26
;*  StrUpper             convert to UPPER case
;*  StrVar               recall a String variable T_StrVar ID
;*m STROFF()             covert index in .A to an offset in .X based on size of pointer
;*
#ifdef hide
.NOLIST
#endif

.list

; STRSZ			Size for STRBUF
; Int(ZStr) 		ZStr points to string result
; Short(ZStrLen)	Length of STRBUF used (write index)

;----------------------------------------------- String
; (Z) ->    LenL|LenH|Characters.....|00|
; Int(STR_PTR) 	; pointer to string
; Int(STR_END) 	; end of string work area
; Int(STR_LEN) 	; no of chars + 3 (1Null+2Len)

; RAMBEG
; BASBEG          BASEND      VAREND        STR_END  ARYBEG  RAMEND
;   |  Program lines | Variables | String work | Free | Arrays |  blank | ROM

; NUM_A has Sgn,Exp, A,B,C...

; re-use NUM_A A,B to point to the top most string
#define S_PTR_A NUM_AA
; re-use NUM_A S,X as the length
#define S_LEN_A NUM_AS

; re-use NUM_B A,B to point to the operand string
#define S_PTR_B NUM_BA
; re-use NUM_B S,X as the length of opperand
#define S_LEN_B NUM_BS

; STROFF()  covert index in .A to an offset in .X based on size of pointer
#define STROFF() asl a\ tax

_Str 		= $

; when storing a sting,
; if the variable's pointer is zero then
;    allocate a new space and set pointer
;    copy the data to the string space checking limit
; otherwise
;    copy data to it, checking limit
 		;--
; ZPtr must point to the memory block

;----------------------------------------------- EvString
EvString: ; Evuate a string expression -> STRBUF
; return T=OK, F otherwise
 		jsr 	StrPush 	; create a temp space

 		;-- term counter, dec with each term
 		lda 	#0
 		sta 	EVFLG
 		;-- for now, just handle one item


EvStrPart	jsr 	EvStrItem
 		RTN_IFF()

EvStrL 		;-- while '+'
 		lda 	CHRGOT
 		cmp 	#'+'
 		bne 	EvStrX
 		;-- {
 		jsr 	ChrRd 		; consume the '+'
 		jsr 	StrPush 	; push working string
 		jsr 	EvStrItem 	; get next part
 		RTN_IFF() 		; missing term !
 		jsr 	StrAppend 	; append it
 		bra 	EvStrL 		; loop around
 		;-- }

EvStrX 		RTN_T()

;----------------------------------------------- EvStrItem
EvStrItem: ; get a single item T_StrLit |T_StrVar| StrFn
 		lda 	CHRGOT
 		;-- string Value ?
 		CASE(T_StrLit,StrLit)
 		CASE(T_StrVar,StrVar)
 		;-- BR_AEQ(T_StrAry,RtnTrue)
 		jsr	StrIsFn
		BR_T(EvStrFn)		; yes, perform function
 		RTN_F()
EvStrFn:; evaluate string function FN$($ [,~]* )
		pha			; save the FnToken
		jsr	ChrRd		; move on (consume token)
		jsr	EvStrPart	; eval strexpr
		pla			; pop token
		jsr	StrFnDo		; execute function
		;- back here to check for ')'
 		lda 	#')'
 		jsr 	Match
		RTN_T()
; RunJump returns to where this was called from
StrFnDo		jmp 	RunJump		; dispatch to function to process


;----------------------------------------------- StrVar
StrVar: ; recall a String variable T_StrVar ID
 		jsr 	ChrRd 		; consume T_StrVar, get ID
; 		bpl 	StrVar1
; 		ERROR(ERR_BADVAR) 	; invalid varname
StrVar1 	;-- recall the variable
 		and 	#$1F 		; mask off index
 		pha
 		jsr 	ChrRd 		; consume ID, move on to '+'/end
 		pla
 		;-- drop through to recall
;----------------------------------------------- StrGet
StrGet: ; get string at index A  A$..Z$ 1..26
 		STROFF()
 		lda 	VARSTR,X
 		sta 	ZPtr
 		lda 	VARSTR+1,X
 		sta 	ZPtr+1
 		ora 	ZPtr
 		bne 	StrLoad 	; string exists
 		;-- no string data yet
 		RTN_F()
StrLoad 	jsr 	StrPoint 	; ZTgt=point ZCnt=Length
 		ZCPY(ZSrc,ZTgt) 	; from hi-mem
 		ZCPY(ZTgt,S_PTR_A)

 		ldy 	#0
 		;-- copy upto and including the null (not whole block)
StrLoadL 	lda 	(ZSrc),y
 		sta 	(S_PTR_A),Y
 		beq 	StrLoadX 	; ending null
 		iny
 		bne 	StrLoadL 	; max out at 255
 		;-- overflow, so back up and null
 		jsr 	StrOvr
 		;-- fall through to save index
StrLoadX 	sty 	S_LEN_A
 		ZCPY(STR_LEN,S_LEN_A)
 		RTN_T()

;----------------------------------------------- StrLit
StrLit: ; Recall a string literal
; CHRGOT is T_StrLit, ChrRd will get the first character
 		ldy 	#0
 		sty 	S_LEN_A+1 	; clear high
StrLitL 	jsr 	ChrRd 		; read literal from code
 		sta 	(S_PTR_A),Y
 		beq 	StrLitX 	; ending null
 		iny
 		bne 	StrLitL 	; max out at 255
 		;-- overflow, so back up and null
 		jsr 	StrOvr
 		;-- fall through to save index
StrLitX 	sty 	S_LEN_A
 		ZCPY(STR_LEN,S_LEN_A)
 		dec 	EVFLG 		; note that we got something
 		;-- move on to next byte in code
 		jsr 	ChrRd
 		RTN_T()

;----------------------------------------------- StrSet
StrSet: ; Store string at index A  A$..Z$ 1..26
 		STROFF()
 		lda 	VARSTR,X
 		sta 	ZPtr
 		lda 	VARSTR+1,X
 		sta 	ZPtr+1
 		ora 	ZPtr
 		bne 	StrSave 	; string already exists

 		;-- no string yet, calc size to next 16
 		ZCPY(ZCnt,S_LEN_A) 	; length needed
 		jsr 	EdtAlloc 	; find/create space, overwrites Zptr

StrSave 	;- ZPtr points to the string space
 		jsr 	StrPoint
 		;-- Src = S_PTR_A
 		ZCPY(ZSrc,S_PTR_A)
 		;-- copy bytes
 		jsr 	EdtDwn
 		rts

;----------------------------------------------- StrPoint
StrPoint: ; (ZPtr)->Object, Exits (ZTgt)->data and ZCnt=Size
 		ldy 	#0
 		lda 	(ZPtr),y
 		sta 	ZCnt
 		iny
 		lda 	(ZPtr),y
 		sta 	ZCnt+1
 		;-- Tgt = Ptr + 2
 		ZCPY(ZTgt,ZPtr)
 		ZINC(ZTgt)
 		ZINC(ZTgt)
 		rts



EvStrNxt 	;-- next token
 		jsr 	ChrRd
 		bne 	EvStrL
 		rts

;----------------------------------------------- EvIsStr
; used by print, which then calls EvString
EvIsStr: ; Return EQ if A is a string value/function
 		BR_AEQ(T_StrLit,StrTrue)
 		BR_AEQ(T_StrVar,StrTrue)
 		BR_AEQ(T_StrAry,StrTrue)
;----------------------------------------------- StrIsFn
StrIsFn: ; Return T/F if .A is a string function (A preserved)
; 		lda 	CHRGOT
 		cmp	#T_FSTR		; 1st string function
 		beq	StrTrue
 		bpl 	StrTrue
		RTN_F()
StrTrue 	RTN_T()

;======================================================================================

;----------------------------------------------- StrInit
StrInit: ;Initialise string buffer
 		ZCPY(STR_END,VAREND) 	; point to open area
 		ZSET(STR_LEN,0) 	; set length as zero
 		rts

;----------------------------------------------- StrPush
StrPush: ;Push temp string sets up S_PTR_A,S_LEN_A
 		jsr 	NumPushA
 		;--
 		ZADD(STR_END,STR_LEN)
 		ZCPY(S_PTR_A,STR_END) 	; set pointer
 		ZSET(STR_LEN,0) 	; set length as zero
 		ZSET(S_LEN_A,0) 	; zero length
#if _DB_STR
 		PRINTLN("StrPushX")
 		jsr 	DB_Str
#endif
 		rts

;----------------------------------------------- StrOvr
StrOvr: ; Overflow - truncate
 		dey 			; back up to last char
 		lda 	#0 		; make it null
 		sta 	(S_PTR_A),Y
StrEnd 		sty 	S_LEN_A
 		rts



;----------------------------------------------- StrAppend
StrAppend: ; Append top two strings (PopB, append)
; StrPush sets it up so that the second string is already in the right place
; so just swap data and adjust initial length to add second's length
 		jsr 	NumPopB
 		jsr 	NumSwap
 		;-- fall through to get the new length
;----------------------------------------------- StrLen
StrLen: ; check length of Str_A, set in S_LEN_A
 		ldy 	#0
 		sta 	S_LEN_A+1
StrLenL 	lda 	(S_PTR_A),Y
 		beq 	StrLenX
 		iny
 		bne 	StrLenL
StrLenX 	sty 	S_LEN_A
 		rts

;----------------------------------------------- StrOut
StrOut: ; Output the resulting string (cut at 255)
 		ldy 	#0
StrOutL 	lda 	(S_PTR_A),y
 		pha
 		jsr 	PutChr 		; A -> mem/io
 		pla
 		beq 	StrOutX 	; null -> done
 		iny
 		bne 	StrOutL
StrOutX 	rts

;----------------------------------------------- StrUpper
StrUpper: ; convert to UPPER case
 		ldy 	#$FF
StrUpper1 	iny
 		lda 	(S_PTR_A),Y
 		beq 	StrUpperX
 		BR_ALT('a',StrUpper1)
 		BR_AGE('{',StrUpper1)
 		and 	#$DF
 		sta 	(S_PTR_A),Y
 		bra 	StrUpper1
StrUpperX 	RTN_T()

;----------------------------------------------- StrLower
StrLower: ; convert to LOWER case
 		ldy 	#$FF
StrLower1 	iny
 		lda 	(S_PTR_A),Y
 		beq 	StrUpperX
 		BR_ALT('A',StrLower1)
 		BR_AGE('[',StrLower1)
 		ora 	#$20
 		sta 	(S_PTR_A),Y
 		bra 	StrLower1
StrLowerX 	RTN_T()


;======================================================================================

;----------------------------------------------- StrAddNum
StrAddNum: ; Append the converted numeric (in NUM_BUF) to the string
 		jsr 	StrPush 	; create a temp space
 		ldy 	#0
 		sty 	S_LEN_A+1 	; clear high
StrAddNumL 	lda 	NUM_BUF,Y
 		sta 	(S_PTR_A),y
 		beq 	StrAddNumX
 		iny
 		bne 	StrAddNumL
 		;-- overflow, so back up and null
 		jmp 	StrOvr
 		;-- fall through to save index
StrAddNumX 	sty 	S_LEN_A
 		ZCPY(STR_LEN,S_LEN_A)
 		rts


.nolist
#if _DB_STR
;----------------------------------------------- DB_Str
DB_Str: ; Debug String values - PtrA LenA PtrB LenB
 		PUSHALL()
 		PRINTLN("PtrA LenA PtrB LenB")
 		HEX_INT(S_PTR_A)
 		HEX_INT(S_LEN_A)
 		HEX_INT(S_PTR_B)
 		HEX_INT(S_LEN_B)
 		CRLF()
 		PRINTLN("VEND SEND SLEN Zrd")
 		HEX_INT(VAREND)
 		HEX_INT(STR_END)
 		HEX_INT(STR_LEN)
 		HEX_INT(ZRd)
 		CRLF()
 		PAUSE()
 		PULLALL()
 		rts

#ifdef _TEST
;----------------------------------------------- StrTest
Hi:  		.DB 	T_StrLit,"HellO ",0
Big 		.DB 	T_StrLit,"BiG ",0
Wo:  		.DB 	T_StrLit,"WorlD.",0
StrTest
 		jsr 	StrInit
 		ZSET(ZRd,Hi)
 		jsr 	StrLit
 		ZSET(ZRd,Big)
 		jsr 	StrLit
 		jsr 	StrUpper
 		ZSET(ZRd,Wo)
 		jsr 	StrLit
 		jsr 	StrLower
 		jsr 	StrAppend
 		jsr 	StrAppend
 		jsr 	StrOut
 		rts
#endif

#endif

 		;-- ;----------------------------------------------- StrSet
 		;-- StrSet: ; Copy String to the variable at (ZPtr)
; 		ldy 	#0
 		;-- StrSetL 	lda 	(ZStr),y
; 		sta 	(ZPtr),y
; 		beq 	StrSetX 	; null -> done
; 		iny
 		;--
; 		;-- need to check DIM size
 		;--
; 		bne 	StrSetL
; 		lda 	#0
; 		sta 	(ZStr),y
 		;-- StrSetX 	rts
 		;--

 		;-- ;----------------------------------------------- StrAppend
 		;-- StrAppend: ; Append string (ZStr) to STRBUF (Recall)
; 		ldy 	#0
; 		ldx 	ZStrLen
 		;-- StrAddL 	lda 	(ZStr),y
; 		sta 	STRBUF,X
; 		beq 	StrEnd 		; ending null
; 		;--
; 		iny
; 		inx
; 		cpx 	#STRSZ
; 		bne 	StrAddL 	; in size


 		;-- ;----------------------------------------------- StrClr
 		;-- StrClr: ; Clear STRBUF
; 		ldy 	#0
; 		tya
; 		sta 	ZStrLen
 		;-- StrClrL 	sta 	STRBUF,y
; 		iny
; 		cpy 	#STRSZ
; 		bne 	StrClrL
 		;-- StrRtn 		rts

 		;-- ;----------------------------------------------- StrAddChr
 		;-- StrAddChr: ; Add character .A to STRBUF
; 		ldx 	ZStrLen
; 		sta 	STRBUF,x
; 		inx
; 		lda 	#0
; 		sta 	STRBUF,x
; 		cpx 	#STRSZ
; 		bmi 	StrAddChrX
; 		;-- overflow, so back up and null
; 		;-- jmp 	StrOvr
 		;-- StrAddChrX 	stx 	ZStrLen
; 		rts

 		;-- ;----------------------------------------------- PrStrBuf
 		;-- PrStrBuf: ; Print STRBUF -> PutChr -> Mem/IO
; 		LDAX(STRBUF)
; 		jmp 	PrStrAX



 		;-- ;----------------------------------------------- StrTail
 		;-- StrTail: ; Keep from Y onwards
; 		;-- index is outof range so result is empty
; 		cpy 	#STRSZ
; 		bpl 	StrSubMT 	; could jmp to StrClr
; 		;-- index beyond end so result is empty
; 		cpy 	ZStrLen
; 		bpl 	StrSubMT 	; could jmp to StrClr
; 		;--
; 		ldx 	#0
 		;-- StrSubL 	lda 	STRBUF,y
; 		sta 	STRBUF,x
; 		beq 	StrEnd 		; save len & exit
; 		iny
; 		inx
; 		cpx 	#STRSZ
; 		bne 	StrSubL
; 		bra 	StrOvr 		; force stop at max
 		;--
 		;-- ;----------------------------------------------- StrSubMT
 		;-- StrSubMT: ;Make string empty
; 		lda 	#0
; 		sta 	STRBUF
; 		sta 	ZStrLen
; 		rts
 		;--
 		;-- ;----------------------------------------------- StrHead
 		;-- StrHead: ; Truncate STRBUF at Y
; 		;-- index is out of range - keep all
; 		cpy 	#STRSZ
; 		bpl 	StrHeadX 	; keep all
; 		;-- index beyond end - keep all
; 		cpy 	ZStrLen
; 		bpl 	StrHeadX 	; keep all
; 		;-- place the nul
; 		lda 	#0
; 		sta 	STRBUF,Y
; 		;-- save new index
; 		sty 	ZStrLen
 		;-- StrHeadX 	rts
 		;--
 		;-- ;----------------------------------------------- StrTrim
 		;-- StrTrim: ; trim leading and trailing blanks
; 		ldy 	#$FF
; 		ldx 	#0
 		;-- StrTrim1 	iny
; 		lda 	STRBUF,Y
; 		beq 	StrTrimX 	; null -> done
; 		cmp 	#' '
; 		beq 	StrTrim1 	; blank -> loop
 		;-- StrTrim2 	sta 	STRBUF,X 	; save char
; 		iny
; 		inx
; 		lda 	STRBUF,Y
; 		bne 	StrTrim2 	; copy up to null
; 		sta 	STRBUF,X 	; write the null
; 		dex
 		;-- StrTrim3 	;-- now trim trailing ' '
; 		lda 	STRBUF,X
; 		cmp 	#' '
; 		bne 	StrTrimX 	; non-space -> exit
; 		lda 	#0 		; null the space
; 		sta 	STRBUF,x
; 		dex
; 		bne 	StrTrim3
 		;-- StrTrimX 	rts
 		;--
 		;--
 		;--

.echo "  _Str\t\t"
.echo $-_Str
.echo "\n"
.list

