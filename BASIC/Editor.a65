;=================================================================== EDITOR ===========
;*  EdtAdd               Append TOKBUF line to end of program
;*  EdtClear             Clear variables and arrays
;*  EdtDel               Delete line and fall through to Insert
;*  EdtDwn               Move bytes down (Delete)
;*  EdtOpn               Insert line, provided it is not an 'empty' line (length <5)
;*  EdtOpn               Move memory up
;*  EdtNew               NEW = clear program, variables etc.
;*  EdtSeek              Search for line number >= LN_FIND
;*  EdtTop               Set ZRd up to read from the start of the program space
;*  EdtUp                Move bytes up (Insert)
;*  EdtUpd               Update program with line in TOKBUF
;*
#ifdef hide
.NOLIST
#endif
#if (($/256)>=PG_ROM) & (($/256)<PG_KEY)


;  Int(RAMBEG)	; Start of user ram area (set with cold start)
;  Int(RAMEND)	; End of user ram area (set at cold start)
;  Int(BASBEG)	; Start of BASIC program
;  Int(BASEND)	; end of program, start of variables
;  Int(VAREND)	; end of variables
;  Int(STREND)  ; end of string work area
;  Int(ARYBEG)  ; Start of array Space

; RAMBEG    BASBEG          BASEND      VAREND        STREND  ARYBEG  RAMEND
;   | A-Z Vars | Program lines | Variables | String work | Free | Arrays |  blank | ROM

;-----------------------------------------------
; X_LineNo: ; Get LN_NUM & Set up LN_NXT
; enters with A=CHRGOT=T_LineNo, exit with CHRGOT after the line data
; sets LN_NUM=line number and LN_NXT=address of next line




_Edt 		= $

;----------------------------------------------- EdtNew
EdtNew: ; NEW = clear program, variables etc.
 		;-- Start Basic at start of RAM
 		ZCPY(BASBEG,RAMBEG)
 		ZCPY(ZWr,BASBEG) 	; prepare to write to memory
 		;-- Null terminate Program
 		lda 	#0
 		jsr 	ChrWr 		; Write Character to memory  A -> (ZWr++) , 00->(ZWr)
 		jsr 	ChrWr
 		ZCPY(BASEND,ZWr) 	; Set BASEND
EdtClear: ; Clear variables and arrays
 		ZCPY(ZWr,BASEND) 	; end of code
 		;-- clear variables
 		lda 	#0
 		jsr 	ChrWr
 		jsr 	ChrWr
 		ZCPY(VAREND,ZWr) 	; Set VAREND
 		ZCPY(STREND,ZWr) 	; Set STREND
 		;-- clear arrays
 		ZCPY(ARYBEG,RAMEND)
 		ZDEC(ARYBEG) 		; top the last ram byte
 		lda 	#0
 		sta 	(ARYBEG)
 		RTN_T()

;----------------------------------------------- EdtTop
EdtTop: ; Set ZRd up to read from the start of the program space
 		ZCPY(ZRd,BASBEG)
 		;--
 		rts

;----------------------------------------------- EdtSeek
EdtSeek: ; Search for line number >= LN_FIND
 		jsr 	EdtTop 		; start at the top
 		;-- get the first byte into CHRGOT
EdtSeekL 	lda 	(ZRd)
 		sta 	CHRGOT
 		beq 	EdtSeekEnd 	; end of program space
 		;-- set LN_NUM=line number, LN_NXT=address of next line
 		jsr 	X_LineNo
 		;-- is it >= the one we're looking for?
 		sec
 		lda 	LN_FIND
 		sbc 	LN_NUM
 		sta 	TMP
 		lda 	LN_FIND+1
 		sbc 	LN_NUM+1
 		sta 	TMP+1
 		;-- Equal or greater
EdtSeekEnd 	rts

EdtSeekNxt 	ZCPY(ZRd,LN_NXT)
 		bra 	EdtSeekL

;----------------------------------------------- EdtUpdate
EdtUpd: ; Update program with line in TOKBUF
; LN_FIND has line no from tokbuf
; ZCnt is length of the line in tokbuf
 		jsr 	EdtSeek
 		;-- if CHRGOT is zero we found end of program and must append
 		lda 	CHRGOT
 		beq 	EdtAdd
 		;-- if line no is a match we need to delete first
 		bmi 	EdtIns 		; N:1 NUM>FND -> Insert
 		ora 	TMP
 		bne 	EdtOpn 		; Z:1 -> Delete, then Insert
EdtDel: ; Delete line and fall through to Insert


EdtIns: ; Insert line, provided it is not an 'empty' line (length <5)


 		rts 			; Done

EdtAdd: ; Append TOKBUF line to end of program
 		ZCPY(ZTgt,ZRd) 		; where we read the terminating null
 		ZADD(BASEND,ZCnt) 	; BASEND += Len
 		ZSET(ZSrc,TOKBUF) 	; from the token buffer
 		ldy 	ZCnt
EdtCpy 		lda 	(ZSrc),y
 		sta 	(ZTgt),y
 		dey
 		bpl 	EdtCpy
 		rts
.export BASEND

;=================================================================== INS/DEL ==========

;----------------------------------------------- EdtDwn
; Move bytes down (Delete)
; ZSrc = source start address		Changed
; ZTgt = destination start address	Changed
; ZCnt = number of bytes to move	Preserved
EdtDwn: ;Move bytes down (Delete)
 		ldy 	#0
 		ldx 	ZCnt+1
 		beq 	EdtDwn2
EdtDwn1 	lda 	(ZSrc),Y 	; move a page at a time
 		sta 	(ZTgt),Y
 		iny
 		bne 	EdtDwn1
 		inc 	ZSrc+1
 		inc 	ZTgt+1
 		dex
 		bne 	EdtDwn1
EdtDwn2 	ldx 	ZCnt
 		beq 	EdtDwn4
EdtDwn3 	lda 	(ZSrc),Y 	; move the remaining bytes
 		sta 	(ZTgt),Y
 		iny
 		dex
 		bne 	EdtDwn3
EdtDwn4 	rts

;----------------------------------------------- EdtUp
; Move bytes up (Insert)
; ZSrc = source end address		Changed
; ZTgt = destination end address	Changed
; ZCnt = number of bytes to move 	Preserved
EdtUp: ; Move bytes up (Insert)
 		ZINC(ZSrc) 		; adjust source and target
 		ZINC(ZTgt)
 		;--
 		ldy 	#$FF
 		ldx 	ZCnt+1
 		beq 	EdtUp3
EdtUp1 		dec 	ZSrc+1
 		dec 	ZTgt+1
EdtUp2 		lda 	(ZSrc),Y 	; move a page at a time
 		sta 	(ZTgt),Y
 		dey
 		bne 	EdtUp2
 		lda 	(ZSrc),Y 	; handle Y = 0 separately
 		sta 	(ZTgt),Y
 		dey
 		dex
 		bne 	EdtUp1
EdtUp3 		ldx 	ZCnt
 		beq 	EdtUp5
 		dec 	ZSrc+1
 		dec 	ZTgt+1
EdtUp4 		lda 	(ZSrc),Y 	; move the remaining bytes
 		sta 	(ZTgt),Y
 		dey
 		dex
 		bne 	EdtUp4
EdtUp5 		rts

;----------------------------------------------- EdtOpn
; Move memory up (open up a space)
; ZSrc = source start address		Changed
; ZTgt = destination start address	Changed
; ZCnt = number of bytes to move	Preseved
;
EdtOpn: ; Move memory up
 		ldx 	ZCnt+1 		; the last byte must be moved first
 		clc 			; start at the final pages of ZSrc and ZTgt
 		txa
 		adc 	ZSrc+1
 		sta 	ZSrc+1
 		clc
 		txa
 		adc 	ZTgt+1
 		sta 	ZTgt+1
 		inx 			; allows the use of BNE after the DEX below
 		ldy 	ZCnt
 		beq 	EdtOpn3
 		dey 			; move bytes on the last page first
 		beq 	EdtOpn2
EdtOpn1 	lda 	(ZSrc),Y
 		sta 	(ZTgt),Y
 		dey
 		bne 	EdtOpn1
EdtOpn2 	lda 	(ZSrc),Y 	; handle Y = 0 separately
 		sta 	(ZTgt),Y
EdtOpn3 	dey
 		dec 	ZSrc+1 		; move the next page (if any)
 		dec 	ZTgt+1
 		dex
 		bne 	EdtOpn1
 		rts


.echo "  _Edtor\t"
.echo $-_Edt
.echo "\n"
.nolist
#endif
