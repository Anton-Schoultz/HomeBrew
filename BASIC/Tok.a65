;=================================================================== TOK ============== 
;*  ChkList             List of characters used by IsOneOf
;*  Digit               List of digits 0..9
;*  FetchNum            fetch number from the code -> NUMBER
;*  IsDigit             returns T/F if CHRGOT is a digit 0..9
;*  IsRelOp             returns T/F if CHRGOT is a relational opperator <>=!
;*  L_LineNo            list LineNo
;*  L_Number            list number
;*  L_String            list out string text
;*  List                List from start of program
;*  ListLn              List line pointed to by ZRd
;*  NextLine            point ZRd to the next line NXTLN
;*  OneOf               see if CHRGOT is one of char in ChkList starting at X
;*  P_IsToken           Parse for a token TOKNO, returns found T/F
;*  P_LineNo            Parse line numebr and place int TOKBUF
;*  P_Number            parse a number into token & value
;*  P_String            parse quoted string into token
;*  Parse               Parse INBUF into TOKBUF
;*  RelOp               Relational opperators
;*  SkipBlank           Skip over leading blank/tabs,  ERR if null
;*  TokEnd              place end of line
;*  TokExpand           Expand the token to key word (X is index)
;*  TokFind             try to find a matching token
;*  X_LineNo            Get LNNUM & Set up NXTLN
;*
#ifdef hide
.NOLIST
#endif

PARAGRAPH()
_Tok 		= $

;----------------------------------------------- ChkList 
ChkList: ; List of characters used by IsOneOf
RelOp: ; Relational opperators
.DB 	"<>=!", 0
Digit: ; List of digits 0..9
.DB 	"0123456789",0

#define T_LineNo $FF
#define T_Number $FE
#define T_String $FD


;----------------------------------------------- Parse 
Parse: ;Parse INBUF into TOKBUF
 		;-- read from memory INBUF
 		ZSET(ZRd,INBUF-1) 	; read memory from INBUF
 		PR_RD_MEM() 		; read from memory (ZRd)
 		PR_ECHO_OFF() 		; don't echo it
 		;-- write to TOKBUF
 		ZSET(ZWr,TOKBUF) 	; point to TOKBUF
 		PR_WR_MEM() 		; write to memory

 		;-- prime pump -> CHRGOT
 		JSR 	RdCh

 		;-- line number ?
 		JSR 	SkipBlank 	; skipover leading blank/tabs
 		JSR 	IsDigit
 		BR_F(P_Stmnt) 		; not a digit -> Statement?
 		;-- digit - so do line number
 		JSR 	P_LineNo
 		;-- fall through for the rest of the statement

P_Stmnt 	;-- return if end of line NULL
 		JSR 	RdCh
 		BNE 	P_KeyWord
 		;-- end of input line, check for T_LnNo
 		LDA 	TOKBUF
 		BR_ANE(T_LineNo,P_StmntX)
 		;-- line no, so get line length
 		SEC
 		LDA 	ZWr
 		SBC 	#LOW(TOKBUF+3)
 		;-- fill it in
 		STA 	TOKBUF+3
 		;-- 


P_StmntX 	RTS

 		;-- check for keyword
P_KeyWord 	JSR 	P_IsToken 	; check if a keyword
 		BR_F(PNotKey) 		; no -> PNotKey
 		;-- have a token in A, place it and continue
 		JSR 	ChrWr
 		BRA 	P_Stmnt 	; loop for more

PNotKey 	;-- not a keyword, see if we have a number
 		JSR 	IsDigit 	; check if CHRGOT is a digit
 		BR_F(PNotDigit)
 		;-- digit, so collect as number
 		JSR 	P_Number 	; parse number and tokenise it
 		BRA 	P_Stmnt 	; loop for more

PNotDigit 	; not number, is it a quoted string?
 		LDA 	CHRGOT
 		BR_ANE('"',PNotStr) 	; A<>" -> PNotStr
 		;-- do parse for [Str] xxxxxx 00
 		JSR 	P_String
 		BRA 	P_Stmnt 	; more

PNotStr 	; not string, if alpha then varname
 		;-- PR_WR_IO()
 		;-- PRINTLN("SYNTAX ERROR")

PNotVar 	; not varname, so copy as-is
 		LDA 	CHRGOT
 		JSR 	ChrWr
 		BRA 	P_Stmnt



;----------------------------------------------- List Scrn 
List: ; List from start of program
 		;-- set ZRd to point to first line of Program
 		ZSET(ZRd,TOKBUF-1)
 		;-- list to output device IO
 		PR_WR_IO()
 		;-- set to read from memory
 		PR_RD_MEM() 		; read from memory (code space)
 		;-- fall through to list line(s)

;----------------------------------------------- ListLn 
ListLn: ; List line pointed to by ZRd
 		JSR 	RdCh 		; (++ZRd)->A
 		BEQ 	ListLnX 	; null = done
 		;-- expand as needed
 		JSR 	ListTok
 		BRA 	ListLn

ListLnX 	RTS

ListTok 	; detokenise
 		LDA 	CHRGOT
 		CASE(T_Number,L_Number)
 		CASE(T_String,L_String)
 		CASE(T_LineNo,L_LineNo)
 		;-- otherwise token?
 		TAX
 		BR_AGE($80,TokExpand)
 		;-- not token, treat as ASCII
 		JSR 	PrCh
 		RTS

;----------------------------------------------- NextLine 
NextLine: ; point ZRd to the next line NXTLN
 		;-- point ZRd to the start of the lilne
 		LDA 	NXTLN
 		STA 	ZRd
 		LDA 	NXTLN+1
 		STA 	ZRd+1
 		RTS

;----------------------------------------------- TokEnd 
TokEnd: ; place end of line
 		;-- check if there was line no,
 		;-- if so, go fill in the length
 		LDA 	TOKBUF
 		CMP 	#T_LineNo
 		BNE 	TokEndX
 		;-- calc length (-1) & save it
 		LDA 	ZWr
 		CLC
 		SBC 	#LOW(TOKBUF+2)
 		STA 	TOKBUF+3
 		;-- 
TokEndX 	LDA 	#0
 		JSR 	ChrWr
 		JSR 	ChrWr
 		RTS

;----------------------------------------------- SkipBlank 
; returns with ending chr in A, (C=1 if A==null)
SkipBlankL 	; read next
 		JSR 	RdCh 		; get from io or mem
SkipBlank: ; Skip over leading blank/tabs,  ERR if null
 		;-- null -> exit flase
 		LDA 	CHRGOT
 		BEQ 	SkipBlankF
 		;-- blank
 		BR_AEQ(' ',SkipBlankL) 	; Space -> Loop
 		BR_AEQ(HT,SkipBlankL) 	; TAB   -> loop
 		;-- ok
SkipBlankT 	RTN_T()
SkipBlankF 	RTN_F()

;----------------------------------------------- IsRelOp 
IsRelOp: ; returns T/F if CHRGOT is a relational opperator <>=!
 		LDX 	#(RelOp-ChkList)
 		JMP 	OneOf

;----------------------------------------------- IsDigit 
IsDigit: ; returns T/F if CHRGOT is a digit 0..9
 		LDX 	#(Digit-ChkList)
 		JMP 	OneOf

;----------------------------------------------- OneOf 
OneOf: ; see if CHRGOT is one of char in ChkList starting at X
 		LDA 	ChkList,X
 		BEQ 	OneOfNo
 		CMP 	CHRGOT
 		BEQ 	OneOfYes
 		INX
 		BNE 	OneOf
OneOfNo 	LDA 	CHRGOT
 		RTN_F() 		; NOPE, set carry & exit
OneOfYes 	LDA 	CHRGOT
 		RTN_T() 		; YES, clear carry & exit

;----------------------------------------------- TokExpand 
TokExpand: ; Expand the token to key word (X is index)
 		LDY 	#0
 		TXA
 		AND 	#$7F
 		STA 	TOKNO
 		CLC
 		ROR 	a 		; A = TokNo / 2
 		TAX 			; index in table
 		CPX 	#0
 		BEQ 	TokExpL0 	; token 80 is special ;P
 		DEY

 		;-- 
TokExpNxt 	CPX 	#0 		; no more
 		BEQ 	TokExpX
 		;-- move to next word
TokExpNxtL 	INY
 		LDA 	TblKeyword,y
 		BEQ 	TokExpXX 	; end of list, not found
 		BPL 	TokExpNxtL
 		;-- got the marker
 		DEX
 		BNE 	TokExpNxtL
TokExpL 	; found the start of the word
 		INY
TokExpL0 	LDA 	TblKeyword,y
 		BEQ 	TokExpX 	; end of list -> done
 		BMI 	TokExpLX 	; last char
 		JSR 	PrCh 		; echo
 		BRA 	TokExpL 	; loop next char

TokExpLX 	AND 	#$7F 		; mask off bit7
 		JSR 	PrCh 		; output it
 		;-- auto space
 		;-- BR_ALT('A',TokExpX) 	; last char was not A-Z -> done
 		;-- LDA 	#' '
 		;-- JSR 	PrCh 		; space and return
 		RTS

TokExpXX 	; not found
 		LDA 	TOKNO
 		JSR 	PrAHex
 		;-- 
TokExpX 	RTS

;----------------------------------------------- P_IsToken 
P_IsToken: ; Parse for a token TOKNO, returns found T/F
 		;-- JSR 	SkipBlank
 		;-- fall through to TokFind
;----------------------------------------------- TokFind 
; TblKeyword	has list of keywords, ending char has $80
; ZRd		points to input, 1st char to try and match Y=0..
; TOKNO		Counts up token number while we search
TokFind: ;try to find a matching token
 		;-- sart with first token no
 		LDA 	#0
 		STA 	TOKNO
 		;-- start index in keyword list
 		LDX 	#$FF
TokWord 	;- test next word
 		LDY 	#0
 		INX
TokWordL 	;-- test a character of the word
 		LDA 	TblKeyword,X
 		BEQ 	TokFail 	; end of Token list
 		BMI 	TokLast 	; bit7=1 marks end
 		;-- 
 		CMP 	(ZRd),Y 	; source char
 		BNE 	TokNxt
 		;-- next char
 		INY
 		INX
 		BRA 	TokWordL
TokLast 	; last character fo keyword
 		AND 	#$7F
 		CMP 	(ZRd),Y
 		BEQ 	TokFound 	; match so we got it!
 		;-- no match, so next word
TokNxt 		; no match
 		INC 	TOKNO
TokNxtL 	LDA 	TblKeyword,X
 		BEQ 	TokFail
 		BMI 	TokWord
 		INX
 		BRA 	TokNxtL
TokFail 	;-- not found, return with CY=1
 		RTN_F()
TokFound 	;-- found !
 		CLC 			; move ZRd to after the keyword
 		TYA
 		ADC 	ZRd
 		STA 	ZRd
 		BCC 	TokRtn
 		INC 	ZRd+1
 		;-- get token number from the counter
TokRtn 		LDA 	TOKNO
 		ASL 	A 		; token nos incr in 2s
 		ORA 	#$80 		; and have high bit set
 		;-- return Found=True, A=token
 		RTN_T()

;=================================================================== NUMBER =========== 

;----------------------------------------------- P_Number 
P_Number: ; parse a number into token & value
; for now were only doing 16bit int numbers
 		;-- Write Number token
 		LDA 	#T_Number
 		JSR 	ChrWr
 		;-- Parse number value
 		JSR 	RdNum
 		;-- write number value
 		LDA 	NUMBER
 		JSR 	ChrWr
 		LDA 	NUMBER+1
 		JSR 	ChrWr
 		;-- 
 		RTS
;----------------------------------------------- L_Number 
L_Number: ; list number
 		;-- get number from code -> NUMBER
 		JSR 	FetchNum
 		;-- convert & output number
 		JSR 	PrNum
 		LDA 	#' '
 		JSR 	PrCh
 		;-- 
 		RTS
;----------------------------------------------- FetchNum 
FetchNum: ; fetch number from the code -> NUMBER
 		JSR 	ChrRd
 		STA 	NUMBER
 		JSR 	ChrRd
 		STA 	NUMBER+1
 		LDA 	#0
 		STA 	NUMBER+2
 		RTS

;=================================================================== STRING =========== 

;----------------------------------------------- P_String 
P_String: ; parse quoted string into token
 		;-- Write Number token
 		LDA 	#T_String
 		JSR 	ChrWr
 		;-- Copy until the closing quote
P_StrL 		JSR 	ChrRd
 		BEQ 	P_StrX 		; null -> done
 		BR_AEQ('"',P_StrX) 	; quote -> done
 		JSR 	ChrWr 		; copy to TOKBUF
 		BRA 	P_StrL 		; loop back for more
P_StrX 		LDA 	#0
 		JSR 	ChrWr 		; place temrinating null and return
 		RTS

;----------------------------------------------- L_String 
L_String: ; list out string text
 		LDA 	#'"'
 		JSR 	PrCh
 		JSR 	ChrCopy
 		LDA 	#'"'
 		JSR 	PrCh
 		RTS


;=================================================================== LINE_NO ========== 

;----------------------------------------------- P_LineNo 
P_LineNo: ; Parse line numebr and place int TOKBUF
 		;-- Write LineNo token
 		LDA 	#T_LineNo
 		JSR 	ChrWr
 		;-- Parse number value
 		JSR 	RdNum
 		;-- write line number
 		LDA 	NUMBER
 		JSR 	ChrWr
 		LDA 	NUMBER+1
 		JSR 	ChrWr
 		;-- place holder for the length
 		LDA 	#$AA
 		JSR 	ChrWr
 		RTS

;----------------------------------------------- X_LineNo 
X_LineNo: ; Get LNNUM & Set up NXTLN
 		;-- save line no
 		JSR 	ChrRd
 		STA 	LNNUM
 		JSR 	ChrRd
 		STA 	LNNUM+1
 		;-- get length
 		JSR 	ChrRd
 		;-- Now ZRd points to the first char of the line [4]
 		CLC
 		ADC 	ZRd
 		STA 	NXTLN
 		LDA 	#0
 		ADC 	ZRd+1
 		STA 	NXTLN+1
 		;-- 
 		RTS

;----------------------------------------------- L_LineNo 
L_LineNo: ; list LineNo
; ChrRd will get first byte afer the token
 		JSR 	X_LineNo 	; Get LNNUM & Set up NXTLN
 		;-- output line no
 		LDA 	LNNUM
 		STA 	NUMBER
 		LDA 	LNNUM+1
 		STA 	NUMBER+1
 		LDA 	#0
 		STA 	NUMBER+2 	; U=0
 		;-- 
 		JSR 	PrNum
 		LDA 	#' '
 		JSR 	PrCh
 		;-- jump to continue listing
 		RTS


.export TokFind,TOKNO,TokFound,Parse

.export TblKeyword,TblRun


.echo $-_Tok
.echo " Bytes in _Tok\n"

