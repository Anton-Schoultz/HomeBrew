;=================================================================== TOK ==============
;*  BasTop              Setup to read from start of basic, for now TOKBUF
;*  FetchNum            fetch number from the code -> NUMBER -> AX
;*  IsAlpha             returns T/F if .A is a Alpha A-Z
;*  IsAlphaNumeric      returns true if .A is 0-9,A-Z
;*  IsDigit             returns T/F if .A is a digit 0..9
;*  IsRelOp             returns T/F if CHRGOT is a relational opperator <>=
;*  L_LineNo            list LineNo
;*  L_Number            list number
;*  L_String            list out string text
;*  List                List from start of program
;*  ListLit             list literal value
;*  ListLn              List line pointed to by ZRd
;*  NextLine            point ZRd to the next line NXTLN
;*  P_IsToken           Parse for a token, returns TOKNO or CHRGOT, returns found T/F
;*  P_LineNo            Parse line numebr and place int TOKBUF
;*  P_Number            parse a number into token & value
;*  P_String            parse quoted string into token
;*  P_Var               Handle variable name
;*  Parse               Parse INBUF into TOKBUF
;*  ParseIn             Parse from memory into TOKBUF
;*  Run                 Run from start
;*  RunLn               Run [LineNo] Stmnt.... 00
;*  SkipBlank           Skip blank/tabs, end char in A, T if not null
;*  TokErr              display invalid token as [xx]
;*  TokExpand           Expand the token .X to key word
;*  TokExpandA          Expand the token .A to key word
;*  TokFind             try to find a matching token
;*  X_LineNo            Get LNNUM & Set up NXTLN
;*
#ifdef hide
.NOLIST
#endif

_Tok 		= $

; Value tokens, Bit0=Array, Bit1=String, Bit2=Literal
;                  FF			;ff "x" Lit,Alpha, -
T_StrLit 	= $FE 			;fe "x" Lit,Alpha, -
;                  FD			;fd 123	Lit,Num  , -
T_NumLit 	= $FC 			;fc 123	Lit,Num  , -
T_StrAry 	= $FB 			;fb A$(	Var,Alpha,Array
T_StrVar 	= $FA 			;fa A$	Var,Alpha,Single
T_NumAry 	= $F9 			;f9 A(	Var,Num  ,Array
T_NumVar 	= $F8 			;f8 A	Var,Num  ,Single

T_Line 		= $F0 			; header includes line number


BAS_EOL 	= $00 			; end of line
BAS_PRG 	= $00 			; end of program

#define TOKLEN (TOKBUF+3)

;----------------------------------------------- Parse
Parse: ;Parse INBUF into TOKBUF
 		;-- read from memory INBUF
 		ZSET(ZRd,INBUF-1) 	; read memory from INBUF
;----------------------------------------------- ParseIn
ParseIn: ;Parse from memory into TOKBUF
 		PR_RD_MEM() 		; read from memory (ZRd)
 		PR_ECHO_OFF() 		; don't echo it
 		;-- write to TOKBUF
 		ZSET(ZWr,TOKBUF) 	; point to TOKBUF
 		PR_WR_MEM() 		; write to memory
 		jsr 	ParseClr 	; clear TOKBUF
 		;-- prime pump -> CHRGOT
 		jsr 	GetChr
 		;-- line number ?
 		jsr 	SkipBlank 	; skipover leading blank/tabs
 		jsr 	IsDigit
 		BR_F(P_Stmnt) 		; not a digit -> Statement?
 		;-- digit - so do line number
 		jsr 	P_LineNo
 		lda 	CHRGOT

 		;-- fall through to do parts
P_Stmnt 	jsr 	P_Part 		; parse parts until end of line
 		;-- end of input line
 		lda 	#BAS_EOL 	; end-of-line marker
 		jsr 	ChrWr

 		;-- check for T_LnNo, fill in length if needed
 		lda 	TOKBUF
 		BR_ANE(T_Line,P_StmntX)
 		sec
 		lda 	ZWr
 		sbc 	#LOW(TOKLEN+1) 	; one byte offset for ChrGet
 		sta 	TOKLEN
 		sec
 		lda 	ZWr
 		sbc 	#LOW(TOKBUF)
 		sta 	LNLEN
P_StmntX 	rts 			; done with the whole line

;----------------------------------------------- P_Part , P_PartNxt
P_PartNxt 	;- advance and do part
 		jsr 	GetChr
P_Part 		;- parse a part of the line
 		jsr 	SkipBlank 	; skipover leading blank/tabs
 		BR_T(P_KeyWord) 	; Not-null -> P_KeyWord
 		rts 			; null end
P_KeyWord 	;-- check for keyword
 		jsr 	P_IsToken 	; check if a keyword
 		BR_F(PNotKey) 		; no -> PNotKey, A=CHRGOT
 		;-- have a token in A, place it and continue
 		jsr 	ChrWr
 		bra 	P_PartNxt 	; loop for more
PNotKey 	;-- see if we have a number
 		jsr 	IsDigit 	; check if CHRGOT is a digit
 		BR_F(PNotDigit)
 		;-- digit, so collect as number
 		jsr 	P_Number 	; parse number and tokenise it
 		bra 	P_Part 		; loop for more
PNotDigit 	;- is it a quoted string?
 		lda 	CHRGOT
 		BR_ANE('"',PNotStr) 	; A<>" -> PNotStr
 		;-- do parse for [Str] xxxxxx 00
 		jsr 	P_String
 		bra 	P_PartNxt 	; more
PNotStr 	; not string, try varname
 		jsr 	IsAlpha
 		BR_F(PNotVar)
 		jsr 	P_Var
 		bra 	P_Part 		; more
PNotVar 	; not varname, so copy as-is
 		lda 	CHRGOT
 		jsr 	ChrWr
 		bra 	P_PartNxt

;----------------------------------------------- ParseClr
; clear teh tokbuf (not realy required, butmake debuggin easier)
ParseClr 	lda 	#$EE
 		ldy 	#0
ParseClrL 	sta 	TOKBUF,y
 		iny
 		cpy 	#BUFSZ
 		bne 	ParseClrL
 		rts

;----------------------------------------------- BasTop
BasTop: ; Setup to read from start of basic, for now TOKBUF
; for now, just TOKBUF
 		;-- set ZRd to point to first line of Program
 		ZSET(ZRd,TOKBUF-1)
 		;-- set to read from memory
 		PR_RD_MEM() 		; read from memory (code space)
 		;-- list to output device IO
 		PR_WR_IO()
 		rts
;----------------------------------------------- SkipBlankL
; reads next character nad then checks for balnks
SkipBlankL 	; read next
 		jsr 	GetChr 		; get from io or mem
;----------------------------------------------- SkipBlank
; returns with ending chr in A, (C=1 if A==null)
SkipBlank: ; Skip blank/tabs, end char in A, T if not null
 		;-- null -> exit flase
 		lda 	CHRGOT
 		beq 	RtnFalse
 		;-- blank
 		BR_AEQ(SPC,SkipBlankL) 	; Space -> Loop
 		BR_AEQ(HT,SkipBlankL) 	; TAB   -> loop
 		;-- ok
RtnTrue 	RTN_T()
RtnFalse 	RTN_F()


;----------------------------------------------- IsAlpha
IsAlpha: ; returns T/F if .A is a Alpha A-Z
 		BR_ALT('A',RtnFalse)
 		BR_AGE('Z'+1,RtnFalse)
 		RTN_T()
;----------------------------------------------- IsAlphaNumeric
IsAlphaNumeric: ; returns true if .A is 0-9,A-Z
 		jsr 	IsAlpha
 		BR_T(RtnTrue)
 		;-- fall through to check for digit
 		;-- IsDigit
IsDigit: ; returns T/F if .A is a digit 0..9
 		BR_ALT('0',RtnFalse)
 		BR_AGE('9'+1,RtnFalse)
 		RTN_T()


;----------------------------------------------- IsRelOp
IsRelOp: ; returns T/F if CHRGOT is a relational opperator <>=
 		lda 	CHRGOT
 		BR_AEQ('<',RtnTrue) 	; 3c
 		BR_AEQ('=',RtnTrue) 	; 3d
 		BR_AEQ('>',RtnTrue) 	; 3e
 		RTN_F()


;----------------------------------------------- OneOf
; OneOf: ; see if CHRGOT is one of char in ChkList starting at X
; 		lda 	CHRGOT
; 		beq 	OneOfNo 	; null -> exit F
; OneOfL 		lda 	ChkList,X
; 		beq 	OneOfNo
; 		cmp 	CHRGOT
; 		beq 	OneOfYes
; 		inx
; 		bne 	OneOfL
; OneOfNo 	lda 	CHRGOT
; 		RTN_F() 		; NOPE, set carry & exit
; OneOfYes 	lda 	CHRGOT
; 		RTN_T() 		; YES, clear carry & exit

;----------------------------------------------- P_IsToken
P_IsToken: ; Parse for a token, returns TOKNO or CHRGOT, returns found T/F
; If Found, (T)
; 	returns with ZRd pointing at the last matching char
;       so calling GetChr will fetch the character immediately after the token
; If Not Found, (F)
;       returns with ZRd pointing at the first character of the src word


;----------------------------------------------- TokFind
; TblKeyword	has list of keywords, ending char has $80
; ZRd		points to input, 1st char to try and match Y=0..
; TOKNO		Counts up token number while we search
TokFind: ;try to find a matching token
 		;-- sart with first token no
 		lda 	#0
 		sta 	TOKNO
 		;-- start index in keyword list
 		ldx 	#$FF
TokWord 	;- test next word
 		ldy 	#0
 		inx
TokWordL 	;-- test a character of the word
 		lda 	TblKeyword,X
 		beq 	TokFail 	; end of Token list
 		bmi 	TokLast 	; bit7=1 marks end
 		;--
 		cmp 	(ZRd),Y 	; source char
 		bne 	TokNxt
 		;-- next char
 		iny
 		inx
 		bra 	TokWordL
TokLast 	; last character fo keyword
 		and 	#$7F
 		cmp 	(ZRd),Y
 		beq 	TokFound 	; match so we got it!
 		;-- no match, so next word
TokNxt 		; no match
 		inc 	TOKNO
TokNxtL 	lda 	TblKeyword,X
 		beq 	TokFail
 		bmi 	TokWord
 		inx
 		bra 	TokNxtL
TokFail 	;-- not found, return with CY=1
 		lda 	CHRGOT
 		RTN_F()
TokFound 	;-- found !
 		clc 			; move ZRd to after the keyword
 		tya 			; ZRd = ZRd + Y
 		adc 	ZRd
 		sta 	ZRd
 		lda 	#0
 		adc 	ZRd+1
 		sta 	ZRd+1
 		;-- get token number from the counter
TokRtn 		lda 	TOKNO
 		asl 	A 		; token nos incr in 2s
 		ora 	#$80 		; and have high bit set
 		;-- return Found=True, A=token
 		RTN_T()

;----------------------------------------------- TokExpand
TokExpand: ; Expand the token .X to key word
 		txa
TokExpandA: ; Expand the token .A to key word
 		and 	#$7F
 		sta 	TOKNO
 		lsr 	a 		; A = TokNo / 2
 		tax 			; index in table
 		cpx 	#0
 		beq 	TokExpL0 	; token 80 is special ;P

 		ldy 	#$FF

 		;--
TokExpNxt 	cpx 	#0 		; no more
 		beq 	TokExpX
 		;-- move to next word
TokExpNxtL 	iny
 		lda 	TblKeyword,y
 		beq 	TokInvalid 	; end of list, not found
 		bpl 	TokExpNxtL
 		;-- got the marker
 		dex
 		bne 	TokExpNxtL
TokExpL 	;-- found the start of the word
 		iny 			; skip over the last end-of-word marker
TokExpL0 	;-- output the word
 		lda 	TblKeyword,y
 		beq 	TokExpX 	; end of list -> done
 		bmi 	TokExpLX 	; last char
 		jsr 	PutChr 		; echo
 		bra 	TokExpL 	; loop next char

TokExpLX 	;-- last character of the word (marked one)
 		and 	#$7F 		; mask off bit7
 		jsr 	PutChr 		; output it and return
 		cmp 	#'('
 		beq 	TokExpX
 		bra 	TokSpc

TokInvalid 	; not found
 		jsr 	TokErr 		; show error token as [xx]
TokSpc 		lda 	#' '
 		jsr 	PutChr
TokExpX 	rts


;----------------------------------------------- Run
Run: ; Run from start
 		jsr 	BasTop
; code to seek to starting line for listing
; loop to call RunLn for each line

RunL 		jsr 	RunLn 		; (*1)
; NXTLN -> ZRd
; 		bra 	RunL

; end of program
 		rts

;----------------------------------------------- RunLn
RunLn: ; Run [LineNo] Stmnt.... 00
 		jsr 	GetChr 		; (++ZRd)->A
 		sta 	TOKNO
 		;-- line number ?
 		BR_ANE(T_Line,RunStmnt)
 		;-- line number so execute that
 		jsr 	X_LineNo
 		;-- get the byte after the line no
 		jsr 	GetChr 		; (++ZRd)->A
 		sta 	TOKNO
 		;-- fall through
RunStmnt 	;---------------------- STATEMENT
 		;-- end of statement?
 		beq 	RunLnX 		; null = End-of-statement
 		;-- remark ?
 		BR_AEQ(T_Rem,RunLnX) 	; remark skip rest
 		;-- token
 		BR_AGT(T_Max,TokErr) 	; >max = invalid token
 		BR_ALT($80,TokErr) 	; <$80 = invalid token
 		;-- jump to X_xxxx, rts to run loop (*1)
 		and 	#$7F
 		tax
 		jmp 	(TblRun,X) 	; rts->(*2)

RunLnX 		rts 			; done, return

;----------------------------------------------- TokErr
TokErr: ; display invalid token as [xx]
 		lda 	#'['
 		jsr 	PutChr
 		lda 	TOKNO
 		jsr 	PrAHex
 		lda 	#']'
 		jsr 	PutChr
 		rts


;----------------------------------------------- List Scrn
List: ; List from start of program
 		;-- from start
 		jsr 	BasTop
 		;--
; code to seek to starting line for listing
; loop to call ListLn for each line in turn until last one
 		jsr 	ListLn
; end of list
 		rts

PAGE()

;----------------------------------------------- ListLn
ListLn: ; List line pointed to by ZRd
 		jsr 	GetChr 		; (++ZRd)->A
 		beq 	ListLnX 	; null = done
 		jsr 	ListTok 	; Expand		(*1)
 		bra 	ListLn
ListLnX 	jmp 	PrNL 		; NL and return


ListTok 	; detokenise A=CHRGOT
 		sta 	TOKNO
 		CASE(T_Line,L_LineNo) 	;->L_LineNo, rts to (*1)

 		;-- values ?
 		sta 	VARID
 		and 	#$F8
 		cmp 	#$F8
 		bne 	ListNotVar

 		;-- Literal or name ?
 		BBR2 	VARID,ListVarL 	; Bit4: 0=>Var 1=Lit

 		;-- literal value
 		lda 	VARID
 		and 	#$FE 		; force as not Ary
 		sta 	VARID
 		jsr 	ListLit 	; (*2)
 		rts

 		;-- List a VarName
ListVarL 	jsr 	GetChr 		; read name character
 		bmi 	ListVarStp 	; Ending character
 		jsr 	PutChr 		; output letter
 		bra 	ListVarL 	; loop back

ListVarStp 	; last char has bit 7 set
 		and 	#$7F
 		jsr 	PutChr 		; maskoff and output

ListVarStr 	BBR1 	TOKNO,ListVarAry ; String?
 		lda 	#'$' 		; yes, '$'
 		jsr 	PutChr
ListVarAry 	BBR0 	TOKNO,ListVarEnd ; array ?
 		lda 	#'(' 		; yes '('
 		jsr 	PutChr
 		;-- var name ends with null, so skip over that
 		;-- jsr 	GetChr
ListVarEnd 	rts

ListNotVar 	;-- otherwise token?
 		lda 	TOKNO
 		BR_AGT(T_Max,TokErr)
 		BR_ALT($80,ListTokChr)
 		;-- expand the token .A
 		jsr 	TokExpandA
 		rts

ListTokChr 	;-- not token, treat as ASCII
 		jsr 	PutChr

 		rts

ListLit: ; list literal value
 		CASE(T_NumLit,L_Number) ; rtn->(*2)
 		CASE(T_StrLit,L_String) ; rtn->(*2)
 		rts


.export L_LineNo,T_Max

;----------------------------------------------- NextLine
NextLine: ; point ZRd to the next line NXTLN
; one byte short  - GetChr does (++ZRd)-> A
 		;-- point ZRd to the start of the lilne
 		lda 	NXTLN
 		sta 	ZRd
 		lda 	NXTLN+1
 		sta 	ZRd+1
 		rts

;=================================================================== VARIABLE =========
P_Var: ; Handle variable name
; ZRd points at the initial alpha char
 		lda 	#$F8
 		sta 	TOKNO
 		ldy 	#$FF
; scan forward (with Y) for non-alpha/num
P_VarL 		iny
 		lda 	(ZRd),y
 		jsr 	IsAlphaNumeric
 		BR_T(P_VarL) 		; end, output & copy name

; finished reading chars
 		dey 			; back up to last char
 		;-- set it's high bit on
 		lda 	(ZRd),y
 		ora 	#$80
 		sta 	(ZRd),y
 		sta 	VARID 		; save the marked char
 		;-- back to following char
 		iny
 		lda 	(ZRd),y

; if '$' then set Str bit1 and move on
 		cmp 	#'$'
 		bne 	P_Var1
 		SMB1 	TOKNO 		; set STR bit1
 		iny
 		lda 	(ZRd),y

P_Var1 		; if '(' then set Ary bit0 and move on
 		cmp 	#'('
 		bne 	P_Var2
 		SMB0 	TOKNO 		; set ARY bit0
; 		iny
; 		lda 	(ZRd),y

P_Var2 		; output Token from VARID
 		lda 	TOKNO
 		jsr 	ChrWr 		; output token

 		;-- fetch 1st char again (may have had bit 87 set)
 		ldy 	#0
 		lda 	(ZRd),y
 		sta 	CHRGOT

P_Var3 		jsr 	ChrWr 		; output first varname char
 		lda 	CHRGOT
 		bmi 	P_VarMod 	; if only the one go do $(

P_Var4 		jsr 	ChrRd
 		bne	P_Var3
 		rts

P_VarMod 	jsr 	ChrRd
 		BR_AEQ('(',P_VarMod) 	; read over (,$
 		BR_AEQ('$',P_VarMod)

P_VarXX		rts

;=================================================================== NUMBER ===========

;----------------------------------------------- P_Number
P_Number: ; parse a number into token & value
; for now were only doing 16bit int numbers
 		;-- Write Number token
 		lda 	#T_NumLit
 		jsr 	ChrWr
 		;-- Parse number value
 		jsr 	RdNum
; 		ZDEC(ZRd)
 		;-- write number value
 		lda 	NUMBER
 		jsr 	ChrWr
 		lda 	NUMBER+1
 		jsr 	ChrWr
 		;--
 		rts
;----------------------------------------------- L_Number
L_Number: ; list number
 		;-- get number from code -> NUMBER
 		jsr 	FetchNum
 		;-- convert & output number
PrNum 		jsr 	NumCvt
 		jsr 	NumFmt
 		LDAX(NUMBUF)
 		jmp 	PrStrAX

;----------------------------------------------- FetchNum
FetchNum: ; fetch number from the code -> NUMBER -> AX
 		lda 	#0
 		sta 	NUMBER+2
 		jsr 	ChrRd
 		sta 	NUMBER
 		jsr 	ChrRd
 		sta 	NUMBER+1
 		rts

;=================================================================== STRING ===========

;----------------------------------------------- P_String
P_String: ; parse quoted string into token
 		;-- Write Number token
 		lda 	#T_StrLit
 		jsr 	ChrWr
 		;-- Copy until the closing quote
P_StrL 		jsr 	ChrRd
 		beq 	P_StrX 		; null -> done
 		BR_AEQ('"',P_StrX) 	; quote -> done
 		jsr 	ChrWr 		; copy to TOKBUF
 		bra 	P_StrL 		; loop back for more
P_StrX 		lda 	#0
 		jsr 	ChrWr 		; place temrinating null and return
 		rts

;----------------------------------------------- L_String
L_String: ; list out string text
 		lda 	#'"'
 		jsr 	PutChr
 		jsr 	ChrCopy
 		lda 	#'"'
 		jsr 	PutChr
 		rts

;=================================================================== LINE_NO ==========

;----------------------------------------------- P_LineNo
P_LineNo: ; Parse line numebr and place int TOKBUF
 		;-- Write LineNo token
 		lda 	#T_Line
 		jsr 	ChrWr
 		;-- Parse number value
 		jsr 	RdNum
 		;-- write line number
 		lda 	NUMBER
 		jsr 	ChrWr
 		lda 	NUMBER+1
 		jsr 	ChrWr
 		;-- place holder for the length
 		lda 	#$AA
 		jsr 	ChrWr
 		rts

;----------------------------------------------- X_LineNo
X_LineNo: ; Get LNNUM & Set up NXTLN
; enters with A=CHRGOT= T_Line
 		;-- save line no
 		jsr 	ChrRd 		; get lo no
 		sta 	LNNUM
 		jsr 	ChrRd 		; hi num
 		sta 	LNNUM+1
 		;-- get length
 		jsr 	ChrRd
 		;-- ZRd points to the length byte
 		;-- Next call to ChrRd will return the byte after this token
 		clc
 		adc 	ZRd
 		sta 	NXTLN
 		lda 	#0
 		adc 	ZRd+1
 		sta 	NXTLN+1
 		;--
X_LineNoX 	rts

;----------------------------------------------- L_LineNo
L_LineNo: ; list LineNo
; ChrRd will get first byte afer the token
 		jsr 	X_LineNo 	; Get LNNUM & Set up NXTLN
 		;-- output line no
 		lda 	LNNUM
 		sta 	NUMBER
 		lda 	LNNUM+1
 		sta 	NUMBER+1
 		lda 	#0
 		sta 	NUMBER+2 	; U=0
 		;-- Print line no and space
 		jsr 	PrNum
 		lda 	#' '
 		jsr 	PutChr
 		;--
 		rts

.export T_StrLit,T_Line,T_NumLit

.export TokFind,TOKNO,TokFound,Parse

.export TblKeyword,TblRun


.echo "  _Tok\t\t"
.echo $-_Tok
.echo "\n"

