;=================================================================== TOK ==============
;*  IsDigit             returns C=0 if CHRGOT is a digit 0..9
;*  IsRelOp             returns C=0 if CHRGOT is a relational opperator <>=!
;*  List                List from start of program
;*  ListLn              List line pointed to by ZRd
;*  NextLine            point ZRd to the next line NXTLN
;*  NumX10              NUMBER *= 10 (preserves AXY) - destorys NUMTMP
;*  OneOf               see if CHRGOT is one of char in ChkList starting at X
;*  Parse               Parse INBUF into TOKBUF
;*  ParseNum            -- parse a number into NUMBER,
;*  SkipBlank           Skip over leading blank/tabs,  ERR if null
;*  TokEnd              place end of line
;*  TokExpand           Expand the token to key word (X is index)
;*  TokFind             try to find a matching token
;*
#ifdef hide
 		;-- .NOLIST
#endif

_Tok 		= $

;----------------------------------------------- Parse
Parse: ;Parse INBUF into TOKBUF
 		NOP
 		;-- read from memory INBUF
 		ZSET(ZRd,INBUF-1) 	; read memory from INBUF
 		PR_RD_MEM() 		; read from memory (ZRd)
 		PR_ECHO_OFF() 		; don't echo it

 		;-- write to TOKBUF
 		ZSET(ZWr,TOKBUF) 	; point to TOKBUF
 		PR_WR_MEM() 		; write to memory

 		NOP

 		;-- prime pump -> CHRGOT
 		JSR 	RdCh

 		;-- line number ?
 		JSR 	SkipBlank 	; skipover leading blank/tabs
 		JSR 	IsDigit
 		BCS 	PStmt 		; not a digit -> Statement?
 		;-- digit - so do line number
 		JSR 	P_LineNo
PStmt 		; check for opening statement
 		JSR 	SkipBlank 	; skipover blank/tabs
 		JSR 	TokFind
 		BCC 	PStmtBody
 		;-- no keyword -> Syntax Error
 		PR_WR_IO()
 		PRINTLN("SYNTAX ERROR")
 		RTS
PStmtBody 	; have a primary token, now go parse accordingly
 		TAX 			; tok index to X
 		JMP 	(TblParse,X)
 		RTS

;----------------------------------------------- List Scrn
List: ; List from start of program
 		;-- set ZRd to point to first line of Program
 		ZSET(ZRd,TOKBUF-1)
 		;-- list to output device IO
 		PR_WR_IO()
 		;-- set to read from memory
 		PR_RD_MEM() 		; read from memory (code space)
 		;--

;----------------------------------------------- ListLn
ListLn: ; List line pointed to by ZRd
 		JSR 	RdCh 		; (++ZRd)->A
 		BEQ 	ListLnX 	; null = done
 		;-- jump to appropriate lister
 		AND 	#$7F
 		TAX
 		JMP 	(TblList,X)
ListLnX 	RTS

;----------------------------------------------- NextLine
NextLine: ; point ZRd to the next line NXTLN
 		;-- point ZRd to the start of the lilne
 		LDA 	NXTLN
 		STA 	ZRd
 		LDA 	NXTLN+1
 		STA 	ZRd+1
 		RTS

;----------------------------------------------- TokEnd
TokEnd: ; place end of line
 		;-- check if there was line no,
 		;-- if so, go fill in the length
 		LDA 	TOKBUF
 		CMP 	#T_LineNo
 		BNE 	TokEndX
 		;-- calc length (-1) & save it
 		LDA 	ZWr
 		CLC
 		SBC 	#LOW(TOKBUF+2)
 		STA 	TOKBUF+3
 		;--
TokEndX
 		LDA 	#0
 		JSR 	ChrWr
 		JSR 	ChrWr

 		RTS

;----------------------------------------------- SkipBlank
; returns with ending chr in A, (C=1 if A==null)
SkipBlankL 	; read next
 		JSR 	RdCh 		; get from io or mem
SkipBlank: ; Skip over leading blank/tabs,  ERR if null
 		;-- null -> exit C=1
 		SEC
 		LDA 	CHRGOT
 		BEQ 	SkipBlankX
 		;-- blank -> loop
 		CMP 	#' '
 		BEQ 	SkipBlankL 	; next charand test again
 		;-- TAB -> loop
 		CMP 	#HT
 		BEQ 	SkipBlankL 	; next charand test again
 		;-- other exit with C=0
 		CLC
SkipBlankX 	RTS

PARAGRAPH()

ChkList:
RelOp 		.DB 	"<>=!", 0
Digit 		.DB 	"0123456789",0

;----------------------------------------------- IsRelOp
IsRelOp: ; returns C=0 if CHRGOT is a relational opperator <>=!
 		LDX 	#(RelOp-ChkList)
 		JMP 	OneOf
;----------------------------------------------- IsDigit
IsDigit: ; returns C=0 if CHRGOT is a digit 0..9
 		LDX 	#(Digit-ChkList)
 		JMP 	OneOf

;----------------------------------------------- OneOf
OneOf: ; see if CHRGOT is one of char in ChkList starting at X
 		LDA 	ChkList,X
 		BEQ 	OneOfNo
 		CMP 	CHRGOT
 		BEQ 	OneOfYes
 		INX
 		BNE 	OneOf
OneOfNo 	LDA 	CHRGOT
 		RTN_ERR() 		; NOPE, set carry & exit
OneOfYes 	LDA 	CHRGOT
 		RTN_OK() 		; YES, clear carry & exit

;----------------------------------------------- TokExpand
TokExpand: ; Expand the token to key word (X is index)
 		TXA
 		STA 	TOKNO
 		CLC
 		ROR 	a
 		TAX
 		LDY 	#$FF
 		;--
TokExpNxt 	CPX 	#0
 		BEQ 	TokExpX
 		;-- move to next word
TokExpNxtL 	INY
 		LDA 	TblKeyword,y
 		BEQ 	TokExpXX
 		BPL 	TokExpNxtL
 		;-- got the marker
 		DEX
 		BNE 	TokExpNxtL

TokExpL 	INY
 		LDA 	TblKeyword,y
 		BEQ 	TokExpX
 		BMI 	TokExpLX
 		JSR 	PrCh
 		BRA 	TokExpL

TokExpLX 	AND 	#$7F
 		JSR 	PrCh
 		BRA 	TokExpX

TokExpXX 	; not found
 		LDA 	TOKNO
 		JSR 	PrAHex
TokExpX 	RTS

;----------------------------------------------- TokFind
; TblKeyword	has list of keywords, ending char has $80
; ZRd		points to input, 1st char to try and match Y=0..
; TOKNO		Counts up token number while we search
TokFind: ;try to find a matching token
 		;-- sart with first token no
 		LDA 	#0
 		STA 	TOKNO
 		;-- start index in keyword list
 		LDX 	#$FF
TokWord 	;- test next word
 		LDY 	#0
 		INX
TokWordL 	;-- test a character of the word
 		LDA 	TblKeyword,X
 		BEQ 	TokFail 	; end of Token list
 		BMI 	TokEndChar 	; bit7=1 marks end
 		;--
 		CMP 	(ZRd),Y 	; source char
 		BNE 	TokNextWord
 		;-- next char
 		INY
 		INX
 		BRA 	TokWordL
TokEndChar
 		AND 	#$7F
 		CMP 	(ZRd),Y
 		BEQ 	TokFound 	; match so we got it!
 		;-- no match, so next word
TokNextWord 	; no match
 		INC 	TOKNO
TokNextWordL 	LDA 	TblKeyword,X
 		BEQ 	TokFail
 		BMI 	TokWord
 		INX
 		BRA 	TokNextWordL

TokFail 	;-- not found, return with CY=1
 		RTN_ERR()

TokFound 	;-- found return with token in A and CY=0
 		NOP
 		CLC 			; move ZRd to after the keyword
 		TYA
 		ADC 	ZRd
 		STA 	ZRd
 		LDA 	#0
 		ADC 	ZRd+1
 		STA 	ZRd+1
 		;--
 		LDA 	TOKNO
 		ASL 	A 		; token nos incr in 2s
 		RTN_OK()




.export TokFind,TOKNO,TokFound,Parse

.export TblKeyword,TblRun,TblList,TblParse


.echo $-_Tok
.echo " Bytes in _Tok\n"

