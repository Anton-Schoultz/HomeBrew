;=================================================================== EVALUATE =========
;*  ENumLit              fetch number from the code -> NUM_A -> AX
;*  EvFAry               retrieve array variable value -> NumA
;*  EvFBr                Bracketed expression
;*  EvFVar               retrieve variable value -> NumA
;*  EvNumeric            Evaluate numeric expressioni, return T if valid (and CHRGOT is next char)
;*  EvVarLong            Get value of long name variable
;*  Expression           [ Term ]   ( [ +/-] Term)*
;*  Factor               Factor = (BoolTerm) | NumLit | NumVar
;*  Match                match character CHRGOT vs .A and move on, error if no match
;*
#ifdef hide
.NOLIST
#endif

; Match a Specific Input String and move on to next token
#define MATCH(ch) lda #ch\ jsr Match


_Ev 		= $

;----------------------------------------------- EvNumeric
EvNumeric: ; Evaluate numeric expressioni, return T if valid (and CHRGOT is next char)
 		;-- for now, just one factor

 ;	BREAK(1)

 		jmp 	Expression




Expression: ;  [ Term ]   ( [+/-] Term)*
 		lda 	CHRGOT
 		jsr 	IsAddOp
 		bne 	Exp1
 		jsr 	NumZeroA 	; handle unary as implied zero
 		bra 	ExpL
Exp1 		jsr 	Term
		BR_T(ExpL)		; if term is not numeric then exit
		rts
ExpL 		jsr 	IsAddOp
 		bne 	ExpX
 		jsr 	NumPushA
 		jsr 	DoAddOp
 		BR_T(ExpL)		; only if ok
 		RTN_F()
ExpX 		RTN_T()

DoAddOp
 		jsr 	ChrRd
 		jsr 	Term
 		RTN_IFF()		; return if false (non-numeric)
 		jsr 	NumPopB
 		;--
 		lda 	CHRGOT
 		CASE('+',NumAdd)
 		CASE('-',NumSub)
 		RTN_F()


; check iof add op, returns EQ if tru
IsAddOp 	cmp 	#'+'
 		beq 	IsAddOpX
 		cmp 	#'-'
IsAddOpX 	rts



; for now, a Term is a Factor
Term
 		jmp 	Factor

;----------------------------------------------- Factor
Factor: ; Factor = (BoolTerm) | NumLit | NumVar
 		CASE('(',EvFBr) 	; ( BoolTerm )
 		CASE(T_NumVar,EvFVar) 	; variable
 		CASE(T_NumAry,EvFAry) 	; subscripted var
 		CASE(T_NumLit,ENumLit) 	; Literal value
 		RTN_F()

;----------------------------------------------- ENumLit
ENumLit: ; fetch number from the code -> NUM_A -> AX
 		jsr 	ChrRd
 		sta 	NUM_A+0
 		jsr 	ChrRd
 		sta 	NUM_A+1
 		jsr 	ChrRd
 		sta 	NUM_A+2
 		jsr 	ChrRd
 		sta 	NUM_A+3
 		jsr 	ChrRd
 		RTN_T()


;----------------------------------------------- EvFVar
EvFVar: ; retrieve variable value -> NumA
 		jsr 	ChrRd 		; get first letter of name
 		bpl 	EvVarLong 	; get value of long name variable
 		and 	#$1F 		; mask for index
 		asl 	a
 		asl 	a 		; index * 4
 		tax
 		lda 	VARTAB,X
 		sta 	NUM_A+_L
 		lda 	VARTAB+1,X
 		sta 	NUM_A+_H
 		lda 	VARTAB+2,X
 		sta 	NUM_A+_U
 		lda 	VARTAB+3,X
 		sta 	NUM_A+_X
 		jsr 	ChrRd 		; get next token into CHRGOT
 		RTN_T() 		; got a value

;----------------------------------------------- EvVarLong
EvVarLong: ; Get value of long name variable
; TODO
 		RTN_T() 		; got a value


;----------------------------------------------- EvFAry
EvFAry: ; retrieve array variable value -> NumA
; TODO
 		RTN_T() 		; got a value

;----------------------------------------------- FaBr
EvFBr: ; Bracketed expression
 		jsr 	ChrRd 		; consume the '('
; 		jsr 	BoolTerm
 		MATCH($29) 		; check for ')'
 		RTN_T() 		; got a value



;----------------------------------------------- Match
Match: ; match character CHRGOT vs .A and move on, error if no match
 		cmp 	CHRGOT
 		bne 	MatchFail
 		jmp 	ChrRd 		; next tokena nd return
MatchFail 	;
 		PRINT("Excpected char not found")
 		BREAK(1)







.echo "  _Ev\t\t"
.echo $-_Ev
.echo "\n"
.list


