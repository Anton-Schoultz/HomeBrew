;=================================================================== MATH =============
;*  NumAdd               NumA = NumB + NumA
;*  NumCvt               Convert NUM_A(24Bit) to digits in NUM_BUF
;*  NumDH                NUM_A = NUM_A / 100 (24bit) remainder in A
;*  NumDN                NUM_A = NUM_A / ZDIV (48bit), remainder in A [AXY]
;*  NumDT                NUM_A = NUM_A / 10 (48Bit), remainder in A [AXY]
;*  NumDigit             NUM_A = NUM_A * 10 + .A
;*  NumDiv               NumA = NumB / NumA
;*  NumFmt               Apply formatting to leading zeroes based on ZPrFlg
;*  NumIncA              Increment NUM_A
;*  NumInit              Initialise calculator
;*  NumMH                NUM_A = NUM_A * 100 (24bit) - preserves AXY, destroys NUM_TMP
;*  NumMT                NUM_A = NUM_A * 10 (24Bit) - preserves AXY, destroys NUM_TMP
;*  NumMul               NumA = NumB * NumA
;*  NumNegX              2's compliment the mantissa at X
;*  NumNorm              adjust NUM_A so extended bytes are zeroed (/10, incr EXP) set EXP byte
;*  NumPadA              pad extended bytes of Num_A with zeroes
;*  NumParse             -- parse a number from source into NUM_A - destorys NUM_TMP
;*  NumPopB              Pop Num_B from the calculator stack
;*  NumPrep              prepare for Mul/Div by unsigning both
;*  NumPushA             Push Num_A onto calculator stack
;*  NumSign              Move sign from EXP -> Mantissa
;*  NumSpc               blank leading zeroes
;*  NumSub               NumA = NumB - NumA
;*  NumSup               removing leading zeroes
;*  NumUnSign            Move sign from Mantissa -> Exp
;*  NumVal               VAL() Get numeric value (NUM_A) from String (STRBUF)
;*  NumZeroA             place zero into NUM_A
;*  NumZeroB             place zero into NUM_B
;*  NumZeroX             zero the number at .X
;*m HEX_DUMP(adr)        Print hex dump to IO/Mem [Zptr++]
;*
; ZTmp
; ZPtr
; ZPrFlg
; NUM_A
; NUM_TMP
; NUM_BUF

; SGN/EXP,  Low, High, Upper , ...
; #define _X	0
; #define _L	1
; #define _H	2
; #define _U	3


#ifdef hide
.NOLIST
#endif

; Sxxx.xxxx llll.lllll hhhh.hhhh uuuu.uuuu
 		;--

#define LOAD(val) lda #$40\ sta NUM_A+_X\ lda #LOW(val)\ sta NUM_A+_L\ lda #HIGH(val)\ sta NUM_A+_H\ lda #UPPER(val)\ sta NUM_A+_U\ lda #0\ sta NUM_A+_E0\ sta NUM_A+_E1\ sta NUM_A+_E2


; HEX_DUMP(adr) Print hex dump to IO/Mem [Zptr++]
#define HEX_DUMP(adr) ZSET(ZPtr,adr) \ jsr HexDump


_Math 		= $
;----------------------------------------------- NumInit
NumInit: ; Initialise calculator
 		lda 	#0
 		sta 	NUM_SP 		; zero the number stack pointer
 		rts

;----------------------------------------------- NumPushA
NumPushA: ; Push Num_A onto calculator stack
 		ldx 	NUM_SP
 		lda 	NUM_A+_L
 		sta 	CSTK0,X
 		lda 	NUM_A+_H
 		sta 	CSTK1,X
 		lda 	NUM_A+_U
 		sta 	CSTK2,X
 		lda 	NUM_A+_X
 		sta 	CSTK3,X
 		inx
 		txa
 		and 	#$0F
 		sta 	NUM_SP
 		rts
;----------------------------------------------- NumPopB
NumPopB: ; Pop Num_B from the calculator stack
 		dec 	NUM_SP
 		lda 	NUM_SP
 		and 	#$0F
 		sta 	NUM_SP
 		tax
 		lda 	CSTK0,X
 		sta 	NUM_B+_L
 		lda 	CSTK1,X
 		sta 	NUM_B+_H
 		lda 	CSTK2,X
 		sta 	NUM_B+_U
 		lda 	CSTK3,X
 		sta 	NUM_B+_X
 		rts

;----------------------------------------------- NumVal
NumVal: ; VAL() Get numeric value (NUM_A) from String (STRBUF)
 		jsr 	NumZeroA
 		ldy 	#255
NumValL 	iny
 		lda 	NUM_BUF,Y 	; term null
 		beq 	NumValX
 		jsr 	IsDigit 	; messes with A
 		BR_F(NumValX) 		; no more digits
 		;-- ; NUM_A = NUM_A * 10 + .A
 		jsr 	NumDigit
NumValAX 	bra 	NumValL 	; next character
NumValX 	ZCPY4(DBUGNUM,NUM_A) 	; just for me to see it !
 		rts
;----------------------------------------------- NumParse
NumParse: ;-- parse a number from source into NUM_A - destorys NUM_TMP
 		jsr 	NumZeroA
NumParseL 	lda 	CHRGOT 		; term null
 		beq 	NumParseX
 		jsr 	IsDigit 	; messes with A
 		BR_F(NumParseX) 	; no more digits
 		;-- NUM_A = NUM_A * 10 + .A
 		jsr 	NumDigit
NumParseAX 	jsr 	GetChr 		; next character
 		bra 	NumParseL
NumParseX 	ZCPY4(DBUGNUM,NUM_A) 	; just for me to see it !
 		rts

;----------------------------------------------- NumZeroTmp
NumZeroTmp: ; place zero into NUM_TMP
		phx
 		ldx 	#NUM_TMP
 		bra 	NumZeroX

;----------------------------------------------- NumZeroB
NumZeroB: ; place zero into NUM_B
		phx
 		ldx 	#NUM_B
 		bra 	NumZeroX

;----------------------------------------------- NumZeroA
NumZeroA: ; place zero into NUM_A
		phx
 		ldx 	#NUM_A
 		;-- fall through
NumZeroX: ; zero the number at .X (extend version EXP,1,2,3,4,5,6)
 		lda 	#0 		; zero number
 		sta 	_X,X
 		sta 	_L,X
 		sta 	_H,X
 		sta 	_U,X
 		sta 	_E0,x
 		sta 	_E1,x
 		sta 	_E2,x
 		plx
 		rts

;----------------------------------------------- NumDigit
NumDigit: ; NUM_A = NUM_A * 10 + .A
 		jsr 	NumMT 		; A*=10
 		and 	#$0F
 		clc
 		adc 	NUM_A+_L
 		sta 	NUM_A+_L
 		bcc 	NumDigitX
 		inc 	NUM_A+_H
 		bcc 	NumDigitX
 		inc 	NUM_A+_U
NumDigitX 	rts

;----------------------------------------------- NumDH
NumDH: ; NUM_A = NUM_A / 100 (24bit) remainder in A
; 		lda 	#100
; 		sta 	ZDIV
; 		bra 	NumDN
;----------------------------------------------- NumDT
NumDT: ; NUM_A = NUM_A / 10 (48Bit), remainder in A [AXY]
; Divide value at NUM_TMP  by 10, remainder in A [AY]
 		lda 	#10
 		sta 	ZDIV 		; set divisor to 10
NumDN: ; NUM_A = NUM_A / ZDIV (48bit), remainder in A [AXY]
 		ldy 	#48 		; 48 bits (6 bytes)
 		lda 	#0
 		clc
NumDTa 		rol 	A
 		cmp 	ZDIV
 		bcc 	NumDTb
 		sbc 	ZDIV
NumDTb 		rol 	NUM_A+_L 	; L 1
 		rol 	NUM_A+_H 	; H 2
 		rol 	NUM_A+_U 	; U 3
 		rol 	NUM_A+_E0 	; 4
 		rol 	NUM_A+_E1 	; 5
 		rol 	NUM_A+_E2 	; 6
 		dey
 		bpl 	NumDTa
 		rts

;----------------------------------------------- NumMT
NumMT: ; NUM_A = NUM_A * 10 (24Bit) - preserves AXY, destroys NUM_TMP
 		pha
 		ZCPY3(NUM_TMP,NUM_A) 	; NUM_TMP = NUM_A
 		ZSL3(NUM_A) 		; NUM_A * 2
 		ZSL3(NUM_A) 		; NUM_A * 4
 		ZADD3(NUM_A,NUM_TMP) 	; NUM_A += NUM_TMP  (*5)
 		ZSL3(NUM_A) 		; NUM_A = NUM_A * 10
 		pla
 		rts

NumSL:; NUM_A shift left by 1 (*2)
		asl NUM_A+_L
		rol NUM_A+_H
		rol NUM_A+_U
		rol NUM_A+_E0
		rol NUM_A+_E1
		rol NUM_A+_E2
	 	rts


;----------------------------------------------- NumMH
NumMH: ; NUM_A = NUM_A * 100 (24bit) - preserves AXY, destroys NUM_TMP
; 		pha
; 		ZCPY3(NUM_TMP,NUM_A) 	; NUM_TMP = NUM_A  TMP=X
; 		ZSL3(NUM_A) 		; NUM_A 2X
; 		ZSL3(NUM_A) 		; NUM_A 4X
; 		ZSL3(NUM_A) 		; NUM_A 8X
; 		ZADD3(NUM_TMP,NUM_A) 	; TMP = 9X
; 		ZSL3(NUM_A) 		; NUM_A * 16X
; 		ZADD3(NUM_A,NUM_TMP) 	; NUM_A = 16X+9X = 25X
; 		ZSL3(NUM_A) 		; 50x
; 		ZSL3(NUM_A) 		; 100x
; 		pla
; 		rts

;----------------------------------------------- NumSign
NumSign: ; Move sign from EXP -> Mantissa
 		lda 	_X,X 		; sign in EXP byte
 		bpl 	NumNegXX 	; positive so nothing to change
 		and 	#$7F 		; clear sign bit
 		sta 	_X,X 		; put back in EXP
 		bra 	NumNegX 	; complement mantissa
;----------------------------------------------- NumUnSign
NumUnSign: ; Move sign from Mantissa -> Exp
 		lda 	_X,X 		; sign in EXP byte
 		bmi 	NumNegXX 	; already -ve so leave it alone
 		lda 	_U,X
 		bpl 	NumNegXX 	;positive -> leave it
 		lda 	_X,X
 		ora 	#$80
 		sta 	_X,X 		; set sign bit in EXP
 		;-- fall through to complement mantissa
;----------------------------------------------- NumNegX
NumNegX: ; 2's compliment the mantissa at X
 		lda 	#$FF
 		eor 	_L,X
 		sta 	_L,X
 		lda 	#$FF
 		eor 	_H,X
 		sta 	_H,X
 		lda 	#$FF
 		eor 	_U,X
 		sta 	_U,X
 		inc 	_L,X
 		bne 	NumNegXX
 		inc 	_H,X
 		bne 	NumNegXX
 		inc 	_U,X
NumNegXX 	rts

;----------------------------------------------- NumCvt
NumCvt: ; Convert NUM_A(24Bit) to digits in NUM_BUF
 		ldx 	#NUM_A
 		jsr 	NumUnSign 	; move sign to sign/exp byte
 		;-- fill buffer with zeroes
 		ldx 	#NUMSZ-4
 		lda 	#0
 		sta 	NUM_BUF,x
 		dex
 		sta 	NUM_BUF,x
 		dex
NumCvtL 	;- num/10 remainder as digit
 		phx 			; save output index
 		jsr 	NumDT 		; div NUM_TMP by 10, remainder in A
 		plx 			; recall index
 		ora 	#'0' 		; convert remainder to a digit
 		sta 	NUM_BUF,X 	; store the digit
 		dex 			; back-up one pos to the left
 		bpl 	NumCvtL 	; loop until done
 		;-- place EXP
 		lda 	NUM_A+_X
 		and 	#$7F
 		sec
 		sbc 	#$40
 		sta 	NUM_EXP
 		BEQ 	NumCvtS 	; exp is zero so don't place Exx
 		;--
 		;-- TODO  place the point & adjust EXP
		;

 		;-- append the E-##
 		ldx 	#NUMSZ-5
 		tay 			; save exp
 		;-- 'E'
 		lda 	#'E'
 		sta 	NUM_BUF,X
 		inx
 		;-- ['-']
 		tya
 		BPL 	NumCvtE
 		lda 	#'-'
 		sta 	NUM_BUF,X
 		inx
NumCvtE 	; ##
 		tya 			; recal exp
 		phx
 		jsr 	Bin2BCD 	; to bcd in .X .A
 		plx
 		tay 			;Save A for LSD
 		lsr 	a
 		lsr 	a
 		lsr 	a 		; MSD to LSD position
 		lsr 	a
 		ora 	#'0'
 		sta 	NUM_BUF,x
 		inx
 		tya 			; Restore A and then
 		and 	#$0F
 		ora 	#'0'
 		sta 	NUM_BUF,x
 		inx
 		lda 	#0
 		sta 	NUM_BUF,X
NumCvtS 	;-- Place sign in NR[0] based on SGN
 		lda 	#'0' 		; leading zero
 		sta 	NUM_BUF
 		;-- check if negative
 		lda 	NUM_A+_X
 		bpl 	NumCvtX
 		lda 	#'-' 		; replace by '-' for negative
 		sta 	NUM_BUF 	; place sign at Res[0]
NumCvtX 	rts

;----------------------------------------------- NumFmt
NumFmt: ; Apply formatting to leading zeroes based on ZPrFlg
 		BR_ZSUP(NumSup) 	; TMP = NUM_A
 		;-- suppress leading zeroes
 		BR_ZSPC(NumSpc) 	; blank leading zeroes
 		rts

;----------------------------------------------- NumSup
NumSup: ; removing leading zeroes
 		ldx 	#NUMSZ 		; size (to null)
 		dex 			; at least one digit
 		ldy 	#0
NumSupL 	lda 	NUM_BUF,y
 		cmp 	#'0'
 		bne 	NumSupC 	; go copy
 		iny
 		dex
 		bne 	NumSupL
NumSupC 	ldx 	#0
NumSupCL 	lda 	NUM_BUF,y
 		sta 	NUM_BUF,x
 		beq 	NumSupX
 		inx
 		iny
 		bra 	NumSupCL
NumSupX 	rts

;----------------------------------------------- NumSpc
NumSpc: ; blank leading zeroes
 		ldx 	#NUMSZ 		; size (to null)
 		dex 			; at least one digit
 		ldy 	#0
NumSpcL 	lda 	NUM_BUF,y
 		cmp 	#'0'
 		bne 	NumSpcX 	; go copy
 		lda 	#' '
 		sta 	NUM_BUF,y
 		iny
 		dex
 		bne 	NumSpcL
NumSpcX 	rts

;----------------------------------------------- NumAdd
NumAdd: ; NumA = NumB + NumA
 		clc
 		lda 	NUM_B+_L
 		adc 	NUM_A+_L
 		sta 	NUM_A+_L
 		;--
 		lda 	NUM_B+_H
 		adc 	NUM_A+_H
 		sta 	NUM_A+_H
 		;--
 		lda 	NUM_B+_U
 		adc 	NUM_A+_U
 		sta 	NUM_A+_U
 		;--
 		RTN_T()

;----------------------------------------------- NumSub
NumSub: ; NumA = NumB - NumA
 		sec
 		lda 	NUM_B+_L
 		sbc 	NUM_A+_L
 		sta 	NUM_A+_L
 		;--
 		lda 	NUM_B+_H
 		sbc 	NUM_A+_H
 		sta 	NUM_A+_H
 		;--
 		lda 	NUM_B+_U
 		sbc 	NUM_A+_U
 		sta 	NUM_A+_U
 		;--
 		RTN_T()

;----------------------------------------------- NumPrep
NumPrep: ; prepare for Mul/Div by unsigning both
 		ldx 	#NUM_A
 		jsr 	NumUnSign 	; Sign Man->Exp
 		ldx 	#NUM_B
 		jsr 	NumUnSign 	; Sign Mna->Exp
 		;-- work out resultant sign for mul/div
 		lda 	NUM_A+_X
 		eor 	NUM_B+_X
 		and 	#$80 		; just the sign bit
 		sta 	NUM_SGN 	; resultant sign
 		;--
 		;-- NUM_A's exponent as 2's comp
 		lda 	NUM_A+_X
 		and 	#$7F
 		sec
 		sbc 	#$40
 		sta 	NUM_A+_X
 		;--
 		;-- NUM_B's exponent as 2's comp
 		lda 	NUM_B+_X
 		and 	#$7F
 		sec
 		sbc 	#$40
 		sta 	NUM_B+_X
 		;--
 		rts

;----------------------------------------------- NumMul
NumMul: ; NumA = NumB * NumA
 		jsr 	NumPrep 	; pull signs out (make both pos)
 		;-- result Exp = ExpB+ExpA
 		clc
 		lda 	NUM_B+_X
 		adc 	NUM_A+_X
 		sta 	NUM_EXP 	; save on it's own for now
 		;-- zero extended result
 		lda 	#0
 		sta 	NUM_A+_E0
 		sta 	NUM_A+_E1
 		sta 	NUM_A+_E2
 		ldx 	#24 		;There are 24 bits in NA
 		;-- Shift NA to the right, lowest bit into CY
 		lsr 	NUM_A+_U
 		ror 	NUM_A+_H
 		ror 	NUM_A+_L
 		;--
NumMul1 	bcc 	NumMul2 	;0 or 1?
 		;-- bit is 1 so add
 		clc
 		lda 	NUM_B+_L
 		adc 	NUM_A+_E0
 		sta 	NUM_A+_E0
 		;--
 		lda 	NUM_B+_H
 		adc 	NUM_A+_E1
 		sta 	NUM_A+_E1
 		;--
 		lda 	NUM_B+_U
 		adc 	NUM_A+_E2
 		sta 	NUM_A+_E2
 		;--
NumMul2 	;shift result right (equivalent to shift B left )
 		clc
 		ror 	NUM_A+_E2
 		ror 	NUM_A+_E1
 		ror 	NUM_A+_E0
 		ror 	NUM_A+_U
 		ror 	NUM_A+_H
 		ror 	NUM_A+_L
 		;-- loop for each bit
 		dex 			; does not affect CY
 		bne 	NumMul1
 		;-- U H L
 		;-- 6 5 4 3 2 1  0 	NUM_A
 		;-- 00032A5F38D7 XP    Binary fraction
 		;--
 		;-- adjust to fit
 		jsr 	NumNorm
 		RTN_T()

;----------------------------------------------- NumNorm
NumNorm: ; adjust NUM_A so extended bytes are zeroed (/10, incr EXP) set EXP byte
 		lda 	NUM_A+_E2
 		ora 	NUM_A+_E1
 		ora 	NUM_A+_E0
 		beq 	NumNorm2 	; already fits
 		;--
NumNorm1 	jsr 	NumDT 		; divide by 10
 		inc 	NUM_EXP 	; and bump EXP up
 		;-- half round
 		cmp 	#5
 		bmi 	NumNorm 	; < 0.5
 		jsr 	NumIncA 	; round up
 		bra 	NumNorm

NumNorm2 	;- check that high byte bit7 is zero
 		lda 	NUM_A+_U
 		BMI 	NumNorm1 	; set, so /10 again
 		;-- make sign only one bit
 		lda 	NUM_SGN
 		and 	#$80
 		sta 	NUM_SGN
 		;-- get exponent into NUM_A.X
 		lda 	NUM_EXP
 		clc
 		adc 	#$40 		; exp offset
 		ora 	NUM_SGN 	; get sign bit
 		sta 	NUM_A+_X
 		;--
 		RTN_T()

;----------------------------------------------- NumIncA
NumIncA: ; Increment NUM_A
 		inc 	NUM_A+_L
 		bne 	NumIncAX
 		inc 	NUM_A+_H
 		bne 	NumIncAX
 		inc 	NUM_A+_U
 		bne 	NumIncAX
 		inc 	NUM_A+_E0
 		bne 	NumIncAX
 		inc 	NUM_A+_E1
 		bne 	NumIncAX
 		inc 	NUM_A+_E2
NumIncAX 	rts

;----------------------------------------------- NumDiv
NumDiv: ; NumA = NumB / NumA
 		jsr 	NumPrep 	; pull signs out (make both pos)
 		;-- result Exp = ExpB - ExpA
 		sec
 		lda 	NUM_B+_X
 		sbc 	NUM_A+_X
 		sta 	NUM_EXP 	; save on it's own for now
 		;-- place divisor in NUM_DIV
 		ZCPY4(NUM_DIV,NUM_A)
 		;-- zero result (6 bytes)
 		jsr 	NumZeroA
 		;-- zero TMP
 		sta 	NUM_TMP+_L
 		sta 	NUM_TMP+_H
 		sta 	NUM_TMP+_U
 		;--
 		ldx 	#48 		; 48 bit division
NumDivL 	;-- shift a bit from dividend into temp
 		asl 	NUM_B+_L
 		rol 	NUM_B+_H
 		rol 	NUM_B+_U
 		;-- now pull the bit into NUM_TMP
 		rol 	NUM_TMP+_L
 		rol 	NUM_TMP+_H
 		rol 	NUM_TMP+_U
 		;-- try subtract divisor from temp
 		sec
 		lda 	NUM_TMP+_L
 		sbc 	NUM_DIV+_L
 		sta 	NUM_TMP+_L
 		;--
 		lda 	NUM_TMP+_H
 		sbc 	NUM_DIV+_H
 		sta 	NUM_TMP+_H
 		;--
 		lda 	NUM_TMP+_U
 		sbc 	NUM_DIV+_U
 		sta 	NUM_TMP+_U
 		;-- if ok, shift 1 into result
 		bcs 	NumDivL2 	; continue C=1
 		;-- subtract failed, put it back (C=0) at this point
 		lda 	NUM_TMP+_L
 		adc 	NUM_DIV+_L
 		sta 	NUM_TMP+_L
 		;--
 		lda 	NUM_TMP+_H
 		adc 	NUM_DIV+_H
 		sta 	NUM_TMP+_H
 		;--
 		lda 	NUM_TMP+_U
 		adc 	NUM_DIV+_U
 		sta 	NUM_TMP+_U 	; carry should be zero here
 		clc
 		;--
NumDivL2 	; save result bit
 		rol 	NUM_A+_L
 		rol 	NUM_A+_H
 		rol 	NUM_A+_U
 		rol 	NUM_A+_E0
 		rol 	NUM_A+_E1
 		rol 	NUM_A+_E2
 		;-- next bit
 		dex
 		bne 	NumDivL
 		;--
 		;-- U H L
 		;-- 6 5 4 .3 2 1  0 	NUM_A
 		;-- 00032A.5F38D7 XP    Binary fraction
 		;-- now normalise it



 		RTN_T()






.echo "  _Math\t\t"
.echo $-_Math
.echo "\n"
.list
