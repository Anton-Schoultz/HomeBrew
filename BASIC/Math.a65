.nolist
;=================================================================== COMMON ===========
; Common to all math modules
;*  NumInit              Initialise calculator (clear stack pointer)
;*  NumParse             Parse number from (ZRd) and move ZRd
;*  NumPopB              Pop Num_B from the calculator stack (NUM_SP--  S,X,A,B,C)
;*  NumPushA             Push Num_A onto calculator stack (S,X,A,B,C NUM_SP++)
;*  NumStackErr          'out-of-memory'
;*  NumSwap              Swap NUM_A <-> NUM_B  (S,X,A,B,C)
;*

Use_Module = 1

#define CSTKSZ 16

; this lets me select which maths implementation to use


; SGN,  X:Exp, A:Low, B:High, C:Upper
#define FPS	0
#define FPX	1
#define FPA	2
#define FPB	3
#define FPC	4
; extensions to NUM_A & NUM_B for scratch
#define FPD	5
#define FPE	6
#define FPF	7

#define NUM_AS NUM_A+FPS
#define NUM_AX NUM_A+FPX
#define NUM_AA NUM_A+FPA
#define NUM_AB NUM_A+FPB
#define NUM_AC NUM_A+FPC
#define NUM_AD NUM_A+FPD

#define NUM_BS NUM_B+FPS
#define NUM_BX NUM_B+FPX
#define NUM_BA NUM_B+FPA
#define NUM_BB NUM_B+FPB
#define NUM_BC NUM_B+FPC
#define NUM_BD NUM_B+FPD

#define NUM_TMPS NUM_TMP+FPS
#define NUM_TMPX NUM_TMP+FPX
#define NUM_TMPA NUM_TMP+FPA
#define NUM_TMPB NUM_TMP+FPB
#define NUM_TMPC NUM_TMP+FPC
#define NUM_TMPD NUM_TMP+FPD

#define NUM_DIVS NUM_DIV+FPS
#define NUM_DIVX NUM_DIV+FPX
#define NUM_DIVA NUM_DIV+FPA
#define NUM_DIVB NUM_DIV+FPB
#define NUM_DIVC NUM_DIV+FPC



#if ($/256) = 1
;----------------------------------------------- CSTK
; Calc Stack is at bottom of page 1, cpu stack grows down from top of page 1
; 16 x 5 => 80 bytes
CSTK
Var(CSTKS,CSTKSZ) ; S:Sign
Var(CSTKX,CSTKSZ) ; X:Exponent
Var(CSTKA,CSTKSZ) ; A:Low    | S16.L
Var(CSTKB,CSTKSZ) ; B:High   | S16.H
Var(CSTKC,CSTKSZ) ; C:Upper

; Str uses S,X,A,B	SX=Len AB=Ptr

; S16 uses A,B
; S24 uses A,B,C
; D24 uses A,B,C

; F32 uses X,A,B,C
 		;--
; Constants:
; NUMSZ 2	size of a numeric format in internal for - S16 is 2 bytes
; NUMUSZ 5	size of numeric value once 'unpacked' for calcualtions
;----------------------------------------------- Numeric common vars
; Var(NUM_A,NUMUSZ) 	; Number parsed / Primary accumulator
; Var(NUM_TMP,NUMUSZ) 	; Temp number
; Var(NUM_B,NUMUSZ) 	; Secondary accumulator
; Var(NUM_DIV,NUMUSZ) 	; Scratch divisor
; Short(NUM_FLG) 	; Comparisson flags 4:> 2:= 1:<
; Short(NUM_SP) 	; calculator stack pointer
; Short(NUM_SGN) 	; sign
; Var(NUM_BUF,CVTSZ) 	; Conversion work area CVTSZ=14
.nolist
.echo "  CPU Stack\t"
.echo $200 - $
.echo "\tAvailable StackDepth="
.echo CSTKSZ
.echo "\n"

#endif 					; end page1

#if ($/256) > $80
_Math 		= $
.list
#ifdef hide
.NOLIST
#endif

;----------------------------------------------- NumInit
NumInit: ; Initialise calculator (clear stack pointer)
 		lda 	#0
 		sta 	NUM_SP 		; zero the number stack pointer
 		rts

;----------------------------------------------- NumParse
NumParse: ; Parse number from (ZRd) and move ZRd
 		ZCPY(ZParse,ZRd)
 		jsr 	NumParsePtr 	; parse from (ZParse)
 		;-- update ZRd to after the number
 		tya
 		clc
 		adc 	ZRd
 		sta 	ZRd
 		lda 	#0
 		adc 	ZParse+1
 		sta 	ZRd+1
 		rts

;----------------------------------------------- NumPushA
NumPushA: ; Push Num_A onto calculator stack (S,X,A,B,C NUM_SP++)
 		ldx 	NUM_SP
 		;-- sign
 		lda 	NUM_AS
 		sta 	CSTKS,X
 		;-- Exponent
 		lda 	NUM_AX
 		sta 	CSTKX,X
 		;-- value
 		lda 	NUM_AA
 		sta 	CSTKA,X
 		lda 	NUM_AB
 		sta 	CSTKB,X
 		lda 	NUM_AC
 		sta 	CSTKC,X
 		;-- incr and check stack pointer
 		inx
 		txa
 		cmp 	#CSTKSZ
 		beq 	NumStackErr
 		;-- OK, store it
 		sta 	NUM_SP
 		rts
NumStackErr: ; 'out-of-memory'
 		ERROR(ERR_MEMORY)

;----------------------------------------------- NumPopB
NumPopB: ; Pop Num_B from the calculator stack (NUM_SP--  S,X,A,B,C)
 		;-- try decr stak pointer check if <0
 		dec 	NUM_SP
 		bmi 	NumStackErr
 		;-- get it into X
 		ldx 	NUM_SP
 		;-- sign
 		lda 	CSTKS,X
 		sta 	NUM_BS
 		;-- exp
 		lda 	CSTKX,X
 		sta 	NUM_BX
 		;-- value
 		lda 	CSTKA,X
 		sta 	NUM_BA
 		lda 	CSTKB,X
 		sta 	NUM_BB
 		lda 	CSTKC,X
 		sta 	NUM_BC
 		;--
 		rts

;----------------------------------------------- NumSwap
NumSwap: ; Swap NUM_A <-> NUM_B  (S,X,A,B,C)
 		ldx 	#NUMUSZ
NumSwapL 	lda 	NUM_A,X
 		tay
 		lda 	NUM_B,X
 		sta 	NUM_A,X
 		tya
 		sta 	NUM_B,X
 		dex
 		bpl 	NumSwapL
 		rts

#endif 					; end page > $80

.nolist

;=================================================================== MATH MODULE ======
#if Use_Module
#include "Math_S16.a65"
.nolist
#else

;----------------------------------------------- Dummy{
#if $>$400
.echo "\n"
.echo "====================================\n"
.echo " WARNING - Maths module is excluded \n"
.echo "====================================\n"
.echo "\n"

.nolist

;  -------- Module must define these ----------

NumParsePtr	; Parse a number from (ZParse) into NUM_A

NumCvt 		; X_PrNum to display value
NumPrint 	; L_Number to list number (from P_Number)

NumAdd 		; Eval Add
NumSub 		; Eval Subtract
NumMul 		; Eval Multiply
NumDiv 		; Eval Divide
NumMod 		; Eval Modulus

NumAnd 		; Eval   AND
NumOr 		; Eval   OR
NumXor 		; Eval   XOR
NumNot 		; Eval   Negate the true/false result in NUM_A
NumFlag 	; Eval   set flags bassed on result
NumTrue 	; Eval   Place TRUE in NUM_A
NumFalse 	; Eval   Place FALSE in NUM_A

NumFmt 		; X_PrNum (also uses NumCvt)

NumZeroA 	; Eval

NumRnd		; Random number 0-32767  -> NUM_AA,B

NumRd 		; Eval for literal values
NumWr 		; Tok.P_Number to create a literal

NumGet 		; Eval to retrieve from A-Z variable [X] and unpack
NumSet 		; Pack and store into A-Z variable  [X]

NumToInt 	; Return integer value in AX (lo,hi) - sets NUM_FLG
NumFromInt 	; Set NUMA to int value in AX (lo,hi)

; TODO is this really needed?
NumPack		; Pack NUM_A into memory format for storing


#endif
;----------------------------------------------- }Dummy

#endif
.list
