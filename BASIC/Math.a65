.nolist
; this lets me select which maths implementation to use

;-----------------------------------------------
;       Subroutines Required
;-----------------------------------------------

;  NumInit              Initialise calculator

;  NumParse             Parse a number from source into NUM_A
;  NumCvt               Convert NUM_A(unpacked) to digits in NUM_BUF
;  NumPrint             Convert number to string & output (via PutChr mem/io)


;  NumAdd               NumA = NumB + NumA
;  NumSub               NumA = NumB + NumA
;  NumMul               NumA = NumB * NumA (in unpacked form)
;  NumDiv               NumA = NumB / NumA

;  NumPushA             Push Num_A onto calculator stack
;  NumPopB              Pop Num_B from the calculator stack

;  NumFmt               Apply formatting to leading zeroes based on ZPrFlg

;  NumZeroA             Place zero into NUM_A

;  NumSet               Set NUM_A to integer value in AX (lo,Hi)

;  NumRd                Read number from memory using ChrRd & unpack to internal form
;  NumWr                Wwrite number value to memory via ChrWr

;  NumGet              Retrieve simple variable [X] and unpack to internal form
;  NumSet              Pack and Store simple variable [X]

; SGN,  X:Exp, A:Low, B:High, C:Upper
#define FPS	0
#define FPX	1
#define FPA	2
#define FPB	3
#define FPC	4
; extensions to NUM_A & NUM_B for scratch
#define FPD	5
#define FPE	6
#define FPF	7

#define NUM_AS NUM_A+FPS
#define NUM_AX NUM_A+FPX
#define NUM_AA NUM_A+FPA
#define NUM_AB NUM_A+FPB
#define NUM_AC NUM_A+FPC
#define NUM_AD NUM_A+FPD

#define NUM_BS NUM_B+FPS
#define NUM_BX NUM_B+FPX
#define NUM_BA NUM_B+FPA
#define NUM_BB NUM_B+FPB
#define NUM_BC NUM_B+FPC
#define NUM_BD NUM_B+FPD

#define NUM_TMPS NUM_TMP+FPS
#define NUM_TMPX NUM_TMP+FPX
#define NUM_TMPA NUM_TMP+FPA
#define NUM_TMPB NUM_TMP+FPB
#define NUM_TMPC NUM_TMP+FPC
#define NUM_TMPD NUM_TMP+FPD

#define NUM_DIVS NUM_DIV+FPS
#define NUM_DIVX NUM_DIV+FPX
#define NUM_DIVA NUM_DIV+FPA
#define NUM_DIVB NUM_DIV+FPB
#define NUM_DIVC NUM_DIV+FPC


;=================================================================== COMMON =========== 
; Common to all math modules
;*  NumInit              Initialise calculator (clear stack pointer)
;*  NumParse             Parse number from (ZRd) and move ZRd
;*  NumPopB              Pop Num_B from the calculator stack (NUM_SP--  S,X,A,B,C)
;*  NumPushA             Push Num_A onto calculator stack (S,X,A,B,C NUM_SP++)
;*  NumStackErr          'out-of-memory'
;*  NumSwap              Swap NUM_A <-> NUM_B  (S,X,A,B,C)
;*

#if ($/256) = 1
;----------------------------------------------- CSTK 
; Calc Stack is at bottom of page 1, cpu stack grows down from top of page 1
; 16 x 5 => 80 bytes
CSTK
Var(CSTKS,CSTKSZ) ; S:Sign
Var(CSTKX,CSTKSZ) ; X:Exponent
Var(CSTKA,CSTKSZ) ; A:Low    | S16.L
Var(CSTKB,CSTKSZ) ; B:High   | S16.H
Var(CSTKC,CSTKSZ) ; C:Upper

; S16 uses A,B
; F32 uses X,A,B,C
; Str uses S,X,A,B	SX=Len AB=Ptr
 		;-- 
; Constants:
; NUMSZ 2	size of a numeric format in internal for - S16 is 2 bytes
; NUMUSZ 5	size of numeric value once 'unpacked' for calcualtions
;----------------------------------------------- Numeric common vars 
; Var(NUM_A,NUMUSZ) 	; Number parsed / Primary accumulator
; Var(NUM_TMP,NUMUSZ) 	; Temp number
; Var(NUM_B,NUMUSZ) 	; Secondary accumulator
; Var(NUM_DIV,NUMUSZ) 	; Scratch divisor
; Short(NUM_FLG) 	; Comparisson flags 4:> 2:= 1:<
; Short(NUM_SP) 	; calculator stack pointer
; Short(NUM_SGN) 	; sign
; Var(NUM_BUF,CVTSZ) 	; Conversion work area CVTSZ=14
.nolist
.echo "  CPU Stack\t"
.echo $200 - $
.echo "\tAvailable\n"

#endif 					; end page1

#if ($/256) > $80
_Math 		= $
.list
#ifdef hide
.NOLIST
#endif

;----------------------------------------------- NumInit 
NumInit: ; Initialise calculator (clear stack pointer)
 		lda 	#0
 		sta 	NUM_SP 		; zero the number stack pointer
 		rts

;----------------------------------------------- NumParse 
NumParse: ; Parse number from (ZRd) and move ZRd
 		ZCPY(ZParse,ZRd)
 		jsr 	NumParsePtr 	; parse from (ZParse)
 		;-- update ZRd to after the number
 		tya
 		clc
 		adc 	ZRd
 		sta 	ZRd
 		lda 	#0
 		adc 	ZParse+1
 		sta 	ZRd+1
 		rts

;----------------------------------------------- NumPushA 
NumPushA: ; Push Num_A onto calculator stack (S,X,A,B,C NUM_SP++)
 		ldx 	NUM_SP
 		;-- sign
 		lda 	NUM_AS
 		sta 	CSTKS,X
 		;-- Exponent
 		lda 	NUM_AX
 		sta 	CSTKX,X
 		;-- value
 		lda 	NUM_AA
 		sta 	CSTKA,X
 		lda 	NUM_AB
 		sta 	CSTKB,X
 		lda 	NUM_AC
 		sta 	CSTKC,X
 		;-- incr and check stack pointer
 		inx
 		txa
 		cmp 	#CSTKSZ
 		BEQ 	NumStackErr
 		;-- OK, store it
 		sta 	NUM_SP
 		rts
NumStackErr: ; 'out-of-memory'
 		ERROR(ERR_MEMORY)

;----------------------------------------------- NumPopB 
NumPopB: ; Pop Num_B from the calculator stack (NUM_SP--  S,X,A,B,C)
 		;-- try decr stak pointer check if <0
 		dec 	NUM_SP
 		BMI 	NumStackErr
 		;-- get it into X
 		ldx 	NUM_SP
 		;-- sign
 		lda 	CSTKS,X
 		sta 	NUM_BS
 		;-- exp
 		lda 	CSTKX,X
 		sta 	NUM_BX
 		;-- value
 		lda 	CSTKA,X
 		sta 	NUM_BA
 		lda 	CSTKB,X
 		sta 	NUM_BB
 		lda 	CSTKC,X
 		sta 	NUM_BC
 		;-- 
 		rts

;----------------------------------------------- NumSwap 
NumSwap: ; Swap NUM_A <-> NUM_B  (S,X,A,B,C)
 		ldx 	#NUMUSZ
NumSwapL 	lda 	NUM_A,X
 		tay
 		lda 	NUM_B,X
 		sta 	NUM_A,X
 		tya
 		sta 	NUM_B,X
 		dex
 		bpl 	NumSwapL
 		rts

#endif 					; end page > $80

.nolist

;=================================================================== MATH MODULE ====== 
#if 1
#include "Math_S16.a65"
.nolist
#else

;----------------------------------------------- Dummy{ 
#if $>$400
.echo "\n"
.echo "====================================\n"
.echo " WARNING - Maths module is excluded \n"
.echo "====================================\n"
.echo "\n"

.nolist
;  --------- Usages --------------
NumInit 	; Tok.RunLn - when running a line of code
NumParse 	; Tok.P_Number : parse literal number -> NUM_A (follow by NumWr)

NumCvt 		; X_PrNum to display value
NumPrint 	; L_Number to list number (from P_Number)

NumAdd 		; Eval Add
NumSub 		; Eval Subtract
NumMul 		; Eval Multiply
NumDiv 		; Eval Divide
NumMod 		; Eval Modulus

NumAnd 		; Eval   AND
NumOr 		; Eval   OR
NumXor 		; Eval   XOR
NumNot 		; Eval   Negate the true/false result in NUM_A
NumFlag 	; Eval   set flags bassed on result
NumTrue 	; Eval   Place TRUE in NUM_A
NumFalse 	; Eval   Place FALSE in NUM_A

NumPushA 	; Eval push
NumPopB 	; Eval pop

NumFmt 		; X_PrNum (also uses NumCvt)

NumZeroA 	; Eval

NumRd 		; Eval for literal values
NumWr 		; Tok.P_Number to create a literal

NumGet 		; Eval to retrieve A-Z variable [X] X is 1..26
NumSet 		; Eval to store a A-Z variable  [X]

NumToInt 	; Return integer value in AX (lo,hi) - sets NUM_FLG
NumFromInt 	; Set NUMA to int value in AX (lo,hi)

#endif
;----------------------------------------------- }Dummy 

#endif
.list
