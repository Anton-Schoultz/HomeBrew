#ifdef hide
.NOLIST
#endif
#if (($/256)>=PG_ROM) & (($/256)<PG_KEY)
;=================================================================== LIST ==============
;*  ListLn               List line (LnNext called before this)
;*  X_List               Execute List
;*
_List 		= $

#define LST_BEG ZSrc
#define LST_END ZTgt

;----------------------------------------------- X_List
X_List: ; Execute List
 		jsr 	ChrRd 		; consume LIST
 		;-- CLS()
 		;-- Read memory, out to I/O
 		PR_RD_MEM()
 		PR_WR_IO()
		PR_ZSUP_ON()
 		;-- default range
 		ZSET(LST_BEG,0)
 		ZSET(LST_END,65535)
 		;--
 		lda 	CHRGOT
 		BR_ANE(T_NumLit,X_List_0)
 		;-- set from (NumRd will consume the T_NumLit)
 		jsr 	NumRd 		; read value into NUM_A
 		jsr 	ChrRd 		; read char after the num
 		ZCPY(LST_BEG,NUM_AA) 	; set starting value
 		ZCPY(LST_END,NUM_AA) 	; set ending value  (same)

X_List_0 	;- check for a '-'
 		lda 	CHRGOT
 		cmp 	#'-'
 		bne 	X_List_1 	; no
 		;-- default end is max
 		ZSET(LST_END,65535)
 		jsr 	ChrRd 		; consume '-', get next byte
 		;-- check for ending number
 		BR_ANE(T_NumLit,X_List_1)
 		;-- set TO
 		jsr 	NumRd 		; read value into NUM_A
 		ZCPY(LST_END,NUM_AA) 	; set ending value  (same)

X_List_1 	;-- ready to do the listing
 		PRINTLN("LIST FROM -TO-")
 		PRINT("      ")
 		HEX_INT(LST_BEG)
 		HEX_INT(LST_END)
 		CRLF()
 		;-- find the starting line
 		ZCPY(LN_FND,LST_BEG)
 		jsr 	LnSeekTop 	;Seek line>=LN_FND, sets LN_ADR,LN_NUM,LN_NXT

 		;-- TODO check start line is out of range

 		;-- set ending lineno
 		ZCPY(LN_FND,LST_END)

X_List_L 	;-- check last line no
 		jsr 	LnComp

 		PAUSE()

; returns with difference in A (and saved in LN_FLG)
; N:1 Z:0 C:0  MI => NUM<FIND
; N:0 Z:1 C:1  EQ => NUM=FIND Match
; N:0 Z:0 C:1  NE => NUM>FIND
; 		bmi	X_List_1
; 		bmi	X_List1		; not at end yet
; 		beq	X_List1		; last line
; 		rts			; done

	 	; List the line
X_List1		jsr 	ListLn 		; list the line
 		jsr 	LnNext 		; move to next line
 		;-- check if we have a line (length > 0)
 		lda 	LN_LEN		; get length
 		bne 	X_List_L	; non-zero, so loop
		; end of list
X_List_X 	rts

;----------------------------------------------- ListLn
ListLn: ; List line (LnNext called before this)
; line token already processed
		jsr 	ChrRd
 		;-- start by printing the line number
 		lda 	LN_NUM
 		ldx 	LN_NUM+1
 		jsr 	IntPrint
 		lda 	#' '
 		jsr 	PutChr
ListLnL 	lda 	CHRGOT
 		beq 	ListLnX 	; null = dend of line
 		jsr 	ListTok 	; (*1) Expand
 		bra 	ListLnL
ListLnX 	jmp 	PrNL 		; NL and return


;  list a part of the line (token & its data)
ListTok 	sta 	TOKNO
 		;-- Value ?
 		CASE(T_StrLit,L_String)
 		CASE(T_NumLit,L_Number)
 		;-- Variable ?
 		CASE(T_StrVar,VarList)
 		CASE(T_StrAry,VarList)
 		CASE(T_NumVar,VarList)
 		CASE(T_NumAry,VarList)

 		;-- Relational Operator $F1-$F6
 		and 	#$F8
 		cmp 	#$F0
 		bne 	ListTok1
 		;-- expand realtional op
 		BBR2 	TOKNO,ListTokR1 ; '<' ?
 		lda 	#'<'
 		jsr 	PutChr
ListTokR1 	BBR0 	TOKNO,ListTokR2 ; '>' ?
 		lda 	#'>'
 		jsr 	PutChr
ListTokR2 	BBR1 	TOKNO,ListTokR3 ; '=' ?
 		lda 	#'='
 		jsr 	PutChr
ListTokR3 	bra 	ListTokX
 		;--
 		;-- Token ?
ListTok1 	ldx 	TOKNO
 		jsr 	TokExpand
 		BR_T(ListTokX)
 		;-- not token, treat as ASCII
 		lda 	CHRGOT
 		jsr 	PutChr
ListTokX 	jsr 	ChrRd 		; get next byte
 		RTN_T()


;----------------------------------------------- ListDBug
ListDBug: ; debug values
		php
		pha
		phx
		phy

		PRINTLN("BEG  END  NUM  FLG  FND")
		HEX_INT(LST_BEG)
		HEX_INT(LST_END)
		HEX_INT(LN_NUM)

		HEX_INT(LN_FLG)
		HEX_INT(LN_LEN)
		HEX_INT(LN_FND)
		CRLF()

 		;PAUSE()

		ply
		plx
		pla
		plp

 		rts



.echo "  _LIST\t\t"
.echo $-_List
.echo "\n"
.nolist
#endif

;----------------------------------------------- keyword
#if ($/256) = PG_KEY
.list
W_List 		.DB 	"LIS",'T'+$80
.nolist
#endif
;----------------------------------------------- run
#if ($/256) = PG_RUN
.list
T_List 		= LOW($)
.DW 	X_List
.nolist
 		;-- .export T_List
#endif

.list 					; end of List
