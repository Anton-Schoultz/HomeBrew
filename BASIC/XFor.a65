#ifdef hide
.NOLIST
#endif
#if (($/256)>=PG_ROM) & (($/256)<PG_KEY)
;=================================================================== FOR ==============
;*  ForDump              Debug For values
;*  ForPop               Pop for info from stack to inner vars
;*  ForPush              Push FOR structure onto the stack
;*  X_For                FOR <var>=<expr> TO <expr> [STEP <expr>]
;*
_For 		= $
;----------------------------------------------- For/Next
; FOR values are stored immediately after the A-Z, so access with index 27,28
; #define FOR_STP_X 27
; #define FOR_LIM_X 28
; FOR_DATA 	;-- DATA
; Var(FOR_STP,NUMSZ) ; [27] Step size
; Var(FOR_LIM,NUMSZ) ; [28] Limit
; Int(FOR_ADR) 	; Address of loop line (after the FOR line)
; Short(FOR_NDX) 	; Loop variable number (1-26)
;  		;-- STACK	FOR nesting depth FORDEEP=8 (CBM has 9)
; Var(FORSTK,8*FORDEEP)

;----------------------------------------------- X_For
X_For: ; FOR <var>=<expr> TO <expr> [STEP <expr>]
 		;-- Push
 		jsr 	ForPush
 		;-- handle assignment
 		jsr 	ChrRd 		; consume token
 		jsr 	X_LetDo 	; returns index in X
		; store var index
		lda	VARID
 		sta 	FOR_NDX 	; save index
 		;-- save return address
 		ZCPY(FOR_ADR,LN_NXT)
 		;-- TO
 		lda 	#T_TO 		; TO
 		jsr 	Match 		; check for and skip over 'TO'
 		;-- limit
 		;jsr 	ChrRd 		; consume token
 		jsr 	EvNumeric
 		ZCPY(FOR_LIM,NUM_AA)
 		;-- STEP=1 for now
 		ZSET(FOR_STP,1) 	; default step is 1
 		rts

;----------------------------------------------- ForPush
ForPush: ; Push FOR structure onto the stack
 		lda 	FOR_SP
 		asl 	a
 		asl 	a
 		asl 	a 		; a = 8 * sp
 		tay
 		ldx 	#0
 		;-- copy to stack area
ForPushL 	lda 	FOR_DATA,X
 		sta 	FORSTK,y
 		iny
 		inx
 		CPX 	#FORSZ
 		bne 	ForPushL
 		;-- update stack pointer
 		lda 	FOR_SP
 		inc 	a
 		cmp 	#FORDEEP
 		bpl 	ForErr 		; stack overflow
 		sta 	FOR_SP
 		rts

;----------------------------------------------- ForOvr
ForErr 		ERROR(ERR_FOR)

;----------------------------------------------- ForPop
ForPop: ; Pop for info from stack to inner vars
 		;-- decr for stack pointer
 		LDA 	FOR_SP
 		DEC 	a
 		BMI 	ForErr 		; stack underflow
 		STA 	FOR_SP
 		;-- calc offset in stack
 		asl 	a
 		asl 	a
 		asl 	a 		; a = 8 * sp
 		tay
 		ldx 	#0
 		;-- copy from stack area
ForPopL 	lda 	FORSTK,y
 		sta 	FOR_DATA,x
 		iny
 		inx
 		CPX 	#FORSZ
 		bne 	ForPopL
 		rts

#if _DBUG
;=================================================================== DBUG =============
ForDump: ; Debug For values
 		PRINTLN("STP  LIM  ADR  IX SP")
 		HEX_INT(FOR_STP)
 		HEX_INT(FOR_LIM)
 		HEX_INT(FOR_ADR)
 		HEX_SHORT(FOR_NDX)
 		HEX_SHORT(FOR_SP)
 		jmp 	PrNL
#endif


.echo "  _FOR\t\t"
.echo $-_For
.echo "\n"
.nolist
#endif

;----------------------------------------------- keyword
#if ($/256) = PG_KEY
.list
W_For 		.DB 	"FO",'R'+$80
.nolist
#endif
;----------------------------------------------- run
#if ($/256) = PG_RUN
.list
T_For 		= LOW($)
.DW 	X_For
.nolist
 		;-- .export T_For
#endif

.list 					; end of For
