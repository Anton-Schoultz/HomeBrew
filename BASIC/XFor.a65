#ifdef hide
.NOLIST
#endif
#if (($/256)>=PG_ROM) & (($/256)<PG_KEY)
;=================================================================== FOR ==============
;*  DB_For               Debug For values - STP  LIM  ADR  IX SP
;*  ForPop               Pop for info from stack to inner vars
;*  ForPush              Push FOR structure onto the stack
;*  X_For                FOR #V = ##From TO ##Limit [STEP ##Step]~Start of FOR/NEXT Loop
;*
_For 		= $
;----------------------------------------------- For/Next
; FOR values are stored immediately after the A-Z, so access with index 27,28
; #define FOR_STP_X 27
; #define FOR_LIM_X 28
; FOR_DATA 	;-- DATA
; Var(FOR_STP,NUMSZ) ; [27] Step size
; Var(FOR_LIM,NUMSZ) ; [28] Limit
; Int(FOR_ADR) 	; Address of loop line (after the FOR line)
; Short(FOR_NDX) 	; Loop variable number (1-26)
;  		;-- STACK	FOR nesting depth FORDEEP=8 (CBM has 9)
; Var(FORSTK,8*FORDEEP)

;----------------------------------------------- X_For
X_For: ; FOR #V = ##From TO ##Limit [STEP ##Step]~Start of FOR/NEXT Loop
 		;-- Push
 		jsr 	ForPush
 		;-- handle assignment
 		jsr 	ChrRd 		; consume token
 		jsr 	X_LetDo 	; returns index in X
 		;-- store var index
 		lda 	VARID
 		sta 	FOR_NDX 	; save index
 		;-- save return address
 		ZCPY(FOR_ADR,LN_NXT)
 		;-- TO
 		lda 	#T_TO 		; TO
 		jsr 	Match 		; check for and skip over 'TO'
 		;-- limit
 		jsr 	EvNumeric
 		jsr 	NumToInt 	; num as AX l/h
 		sta 	FOR_LIM
 		stx 	FOR_LIM+1
 		;-- STEP?
 		ZSET(FOR_STP,1) 	; default step is 1
 		lda 	CHRGOT
 		beq 	X_ForX 		; STEP ommitted -> done
 		;-- evaluate step size & save it
 		lda 	#T_STEP 	; STEP
 		jsr 	Match 		; check for and skip over 'TO'
 		jsr 	EvNumeric
 		jsr 	NumToInt 	; num as AX l/h
 		sta 	FOR_STP
 		stx 	FOR_STP+1
X_ForX 		rts

;----------------------------------------------- ForPush
ForPush: ; Push FOR structure onto the stack
 		lda 	FOR_SP
 		asl 	a
 		asl 	a
 		asl 	a 		; a = 8 * sp
 		tay
 		ldx 	#0
 		;-- copy to stack area
ForPushL 	lda 	FOR_DATA,X
 		sta 	FORSTK,y
 		iny
 		inx
 		cpx 	#FORSZ
 		bne 	ForPushL
 		;-- update stack pointer
 		lda 	FOR_SP
 		inc 	a
 		cmp 	#FORDEEP
 		bpl 	ForErr 		; stack overflow
 		sta 	FOR_SP
 		rts

;----------------------------------------------- ForOvr
ForErr 		ERROR(ERR_FOR)

;----------------------------------------------- ForPop
ForPop: ; Pop for info from stack to inner vars
 		;-- decr for stack pointer
 		lda 	FOR_SP
 		dec 	a
 		bmi 	ForErr 		; stack underflow
 		sta 	FOR_SP
 		;-- calc offset in stack
 		asl 	a
 		asl 	a
 		asl 	a 		; a = 8 * sp
 		tay
 		ldx 	#0
 		;-- copy from stack area
ForPopL 	lda 	FORSTK,y
 		sta 	FOR_DATA,x
 		iny
 		inx
 		cpx 	#FORSZ
 		bne 	ForPopL
 		rts

#if _DB_FOR
;=================================================================== DBUG =============
DB_For: ; Debug For values - STP  LIM  ADR  IX SP
 		PUSHALL()
 		jsr 	PrNL
 		PRINTLN("STP  LIM  ADR  IX SP")
 		HEX_INT(FOR_STP)
 		HEX_INT(FOR_LIM)
 		HEX_INT(FOR_ADR)
 		HEX_SHORT(FOR_NDX)
 		HEX_SHORT(FOR_SP)
 		jsr 	PrNL
 		PULLALL()
 		PAUSE()
 		rts
#endif


.echo "  _FOR\t\t"
.echo $-_For
.echo "\n"
.nolist
#endif

;----------------------------------------------- keyword
#if ($/256) = PG_KEY
.list
W_For 		.DB 	"FO",'R'+$80
.nolist
#endif
;----------------------------------------------- run
#if ($/256) = PG_RUN
.list
T_For 		= LOW($)+$80
.DW 	X_For
.nolist
#endif

.list 					; end of For
