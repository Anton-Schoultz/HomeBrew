.NOLIST
; Calc
;
; TOS_ML	Mantissa Low 	(also lo of int)
; TOS_MH	Mantissa High	(also hi of int)
; TOS_MU	Mantissa Upper  (upper 24bit int)
; TOS_EXP	Base 10 exp
; TOS_SGN	When unpacked, siign is separate and Exp is 2's compliment of base 10 exp
;
; float values are unpacked when you stick them in here,
; values are pushed/popped, manipulated in unpacked form,
; pack before you store in main memory


#if ($>>8)==0
.org ($+16)/16 * 16
.LIST
;--------------------------------------------------------------------- Calc Z-Page
Var(TOS,4) 	; Top-Of-Stack
Var(NXT,4) 	; Next item on stack

Short(CSP) 	; Calc stack pointer (00->0F)
Short(SGN) 	; sign
Short(EXP) 	; exponent
Short(NUM) 	; number after the 'E'
Short(DIG) 	; digits counter


Var(RES,16) 	; Result (also for convert to string)

#DEFINE CSTKSZ  15

_ML 		= 0
_MH 		= 1
_MU 		= 2
_EXP 		= 3
_SGN 		= 4

TOS_ML 		= TOS+_ML 		; ML	Mantissa Low 	(also lo of int)
TOS_MH 		= TOS+_MH 		; MH	Mantissa High	(also hi of int)
TOS_MU 		= TOS+_MU 		; MU	Mantissa Upper  (upper 24bit int)
TOS_EXP 	= TOS+_EXP 		; EXP	Base 10 exp
TOS_SGN 	= TOS+_SGN 		; SGN	When unpacked, siign is separate and Exp is 2's compliment of base 10 exp

#DEFINE LOAD_TOS(m,exp) lda #LOW(m) \ STA TOS_ML \ lda #HIGH(m) \ sta TOS_MH \ lda #UPPER(m) \ STA TOS_MU \ lda #exp \ STA TOS_EXP \ lda #0 \ sta TOS_SGN


.export TOS,NXT,RES
.export CSP,SGN,DIG,EXP,NUM

.NOLIST
#endif

#if ($>>8)==1
.LIST
;--------------------------------------------------------------------- Calc stack space
; resides below the cpu stack 64 bytes - leaves 192 for cpu
; this is a split stack
Var(CSTK0,16) 	; Stack for LSB
Var(CSTK1,16)
Var(CSTK2,16)
Var(CSTK3,16)
Var(CSTK4,16) 	; Stack for MSB
.NOLIST
#endif


#if CODEPAGE
#ifndef _Calc
#define _Calc



.LIST
PAGE() 		; new page
;===================================================================== CALC
Calc 		;Initialise calculator stack, and zero TOS (unpacked form) [A]
 		ZZP(CSP) 		; Init calc stack pointer to zero
;--------------------------------------------------------------------- CalcZero
CalcZero: ; Set TOS to 0000 E00 (uppacked form) [A]
 		LDA 	#$0 		; +ve, 10^0
 		STA 	TOS_ML
 		STA 	TOS_MH
 		STA 	TOS_MU
 		STA 	TOS_EXP 	; 10^ 0
 		STA 	TOS_SGN 	; $00 => +ve
 		RTS
;--------------------------------------------------------------------- CalcPack
CalcPack: ; Pack TOS_EXP (from 2s exp and SGN) [A]
 		LDA 	TOS_EXP
 		CLC
 		ADC 	#$40 		; add offset
 		STA 	TOS_EXP
 		;-- check SGN
 		LDA 	TOS_SGN
 		BEQ 	CalcPackX 	; +ve so ok
 		LDA 	#0
 		STA 	TOS_SGN
 		LDA 	#$80
 		ORA 	TOS_EXP
 		STA 	TOS_EXP 	; save packed version
CalcPackX 	RTS

;--------------------------------------------------------------------- CalcUnpack
CalcUnpack: ; Unpack TOS_EXP (into 2s exp and SGN) [A]
 		ZZP(TOS_SGN) 		; assume +ve ($00)
 		LDA 	TOS_EXP
 		BPL 	CalcUnpack1
 		DEC 	TOS_SGN 	; minus so set sign as $FF
CalcUnpack1 	AND 	#$7F 		; get power of 10 (with offset)
 		SEC
 		SBC 	#$40 		; subtract offset
 		STA 	TOS_EXP 	; save as 2's comp
 		RTS

;--------------------------------------------------------------------- CalcDup
CalcDup: ; Duplicate TOS (=Push TOS)
;--------------------------------------------------------------------- CalcPush
CalcPush: ; Push TOS onto the stack [AX] !StackErr
 		LDX 	CSP
 		LDA 	TOS+0
 		STA 	CSTK0,X
 		LDA 	TOS+1
 		STA 	CSTK1,X
 		LDA 	TOS+2
 		STA 	CSTK2,X
 		LDA 	TOS+3
 		STA 	CSTK3,X
 		LDA 	TOS+4
 		STA 	CSTK4,X
 		;-- increase stack pointer
 		INC 	CSP 		; next location
 		LDA 	#CSTKSZ 	; check stack size
 		CMP 	CSP 		; C:(A GE mem) Z:A EQ m  N:m GT A
 		BCS 	CalcPushX 	; CSTKSZ is > CSP so OK
CalcStkErr 	THROW(E_STACK) 		; if so, throw stack error
CalcPushX 	RTS
;--------------------------------------------------------------------- CalcDrop
CalcDrop: ; Pop item into TOS item variable [AX]!StackErr
 		JSR 	CalcPop
 		;--
 		LDA 	CSTK0,X
 		STA 	TOS+0
 		LDA 	CSTK1,X
 		STA 	TOS+1
 		LDA 	CSTK2,X
 		STA 	TOS+2
 		LDA 	CSTK3,X
 		STA 	TOS+3
 		LDA 	CSTK4,X
 		STA 	TOS+4
 		RTS
;--------------------------------------------------------------------- CalcPop
CalcPop: ; Reduce stack pointer, .X points to 'popped' item [X] !StackErr
 		;-- force CSP to 0-15
 		DEC 	CSP
 		BMI 	CalcStkErr 	; wrapped arround, so stack error
 		LDX 	CSP
 		RTS




;--------------------------------------------------------------------- CalcAbs
; make the mantissa positive, ready to pack
; X points to TOS / NXT
; The value must be in unpacked format
; Mantissa is check for being negative (2s), made positive by complimenting
; and flipping the sign
CalcAbsX: ; make sure TOS_MAN is +ve, Return sign in Y (0=+, 1=-)
 		LDA 	_MU,X 		; get upper byte into A
 		BPL 	CalcNegXX 	; -ve, so compliment mantissa & flip sign
 		;-- fall through to negate the value
;--------------------------------------------------------------------- CalcCmplAX
CalcNegX: ; Two's compliment of value at X [A]
 		;-- flip sign
 		LDA 	#$FF
 		EOR 	_SGN,X
 		STA 	_SGN,X
 		;--
 		;-- exor mantissa L
 		LDA 	#$FF
 		EOR 	_ML,X
 		STA 	_ML,X
 		;-- H
 		LDA 	#$FF
 		EOR 	_MH,X
 		STA 	_MH,X
 		;-- U
 		LDA 	#$FF
 		EOR 	_MU,X
 		STA 	_MU,X
 		;-- incr mantissa
 		INC 	_ML,X
 		BNE 	CalcNegXX
 		INC 	_MH,X
 		BNE 	CalcNegXX
 		INC 	_MU,X
 		BNE 	CalcNegXX
CalcNegXX 	LDY 	_SGN,X 		; return with the sign in Y
 		RTS









;--------------------------------------------------------------------- CalcFix
CalcFix: ; Fix sign of AX based on SGN (if SGN-ve, then Complement)
 		LDY 	SGN 		; N=1 if -ve
 		BMI 	CalcNegX 	; -ve so go and complement
 		RTS 			; otherwise +ve and we're ok as is


;--------------------------------------------------------------------- CalcRES2TOS
CalcRES2TOS: ; Copy RES to TOS
 		LDX 	#RES
 		BRA 	CalcToTOS
;--------------------------------------------------------------------- CalcNXT2TOS
CalcNXT2TOS: ; Copy NXTS to TOS
 		LDX 	#RES
;--------------------------------------------------------------------- CalcToTOS
CalcToTOS:  	LDX 	#TOS
;--------------------------------------------------------------------- CalcCopy
CalcCopy: ; Copy value from Z,X to Z,Y
 		LDA 	$00,X
 		STA 	$00,Y
 		LDA 	$01,X
 		STA 	$01,Y
 		LDA 	$02,X
 		STA 	$02,Y
 		LDA 	$03,X
 		STA 	$03,Y
 		RTS


;--------------------------------------------------------------------- CalcNext
CalcNext: ; Pop item into NXT item variable
 		JSR 	CalcPop
 		;--
 		LDA 	CSTK0,X
 		STA 	NXT+0
 		LDA 	CSTK1,X
 		STA 	NXT+1
 		LDA 	CSTK2,X
 		STA 	NXT+2
 		LDA 	CSTK3,X
 		STA 	NXT+3
 		RTS

;--------------------------------------------------------------------- CalcSetI
CalcSetI: ; TOS = AX (16 bit signed integer A=lo,X=hi) [AY]
 		STA 	TOS+0
 		STX 	TOS+1
 		LDY 	#0
 		STY 	TOS+2 		; clear high bytes
 		STY 	TOS+3
 		RTS
;--------------------------------------------------------------------- CalcGetI
CalcGetI: ; Return TOS in AX (16 bit signed integer A=lo,X=hi)
 		LDA 	TOS+0
 		LDX 	TOS+1
 		RTS

;--------------------------------------------------------------------- CalcAddI
CalcAddI: ; TOS = NXT + TOS	(16 bit signed integer)
 		JSR 	CalcPop 	; Pop but access onstack with X
 		CLC
 		LDA 	CSTK0,X
 		ADC 	TOS+0
 		STA 	TOS+0
 		;--
 		LDA 	CSTK1,X
 		ADC 	TOS+1
 		STA 	TOS+1
 		;--
 		RTS

;--------------------------------------------------------------------- CalcSubI
CalcSubI: ; TOS = NXT - TOS	(16 bit signed integer)
 		JSR 	CalcPop 	; Pop but access onstack with X
 		SEC
 		LDA 	CSTK0,X
 		SBC 	TOS+0
 		STA 	TOS+0
 		;--
 		LDA 	CSTK1,X
 		SBC 	TOS+1
 		STA 	TOS+1
 		;--
 		RTS

;--------------------------------------------------------------------- CalcAbsTOS
CalcAbsTOS: ; Cvt TOS to absolute, with sign in .Y and SGN
 		LDX 	TOS
 		JSR 	CalcAbsX
 		STY 	SGN
 		RTS

;--------------------------------------------------------------------- CalcAbsNXT
CalcAbsNXT: ; Cvt TOS to absolute, with sign in Y
 		LDX 	NXT
 		JSR 	CalcAbsX
 		RTS

;--------------------------------------------------------------------- CalcSign
CalcSign: ; Set Result SGN and make TOS & NXT positive
 		;-- TOS
 		JSR 	CalcAbsTOS
 		JSR 	CalcAbsNXT
 		TYA
 		EOR 	SGN
 		STA 	SGN
 		RTS

;--------------------------------------------------------------------- CalcMulI
CalcMulI: ; TOS = NXT * TOS	(16 bit signed integer)
; 726 cycles for 123 * 27
 		JSR 	CalcNext 	; pop into NXT
 		JSR 	CalcSign
 		;--
 		LDA 	#0 		;Initialize RES to 0
 		STA 	RES+2
 		LDX 	#16 		;There are 16 bits in TOS
CalcMulI1 	LSR 	TOS+1 		;Get low bit of TOS
 		ROR 	TOS
 		BCC 	CalcMulI2 	;0 or 1?
 		TAY 			;If 1, add NXT (hi byte of RES is in A)
 		CLC
 		LDA 	NXT
 		ADC 	RES+2
 		STA 	RES+2
 		TYA
 		ADC 	NXT+1
CalcMulI2 	ROR 	A 		; shift
 		ROR 	RES+2
 		ROR 	RES+1
 		ROR 	RES
 		DEX
 		BNE 	CalcMulI1
 		STA 	RES+3
 		;-- place result in TOS
 		;--
 		;-- ** copy RES->TOS, then fix TOS *************************************
 		LDA 	RES
 		LDX 	RES+1
 		JSR 	CalcFix
 		;--
 		JMP 	CalcSetI 	; AX -> TOS

;--------------------------------------------------------------------- CalcDivI
CalcDivI: ; TOS = NXT / TOS	(16 bit signed integer)
 		JSR 	CalcNext 	; pop into NXT
 		JSR 	CalcSign

; NXT / TOS => NXT, remainder in RES
 		LDA 	#0 		;Initialize RES to 0
 		STA 	RES
 		STA 	RES+1
 		LDX 	#16 		;There are 16 bits in NXT
CalcDivL1 	ASL 	NXT 		;Shift hi bit of NXT into RES
 		ROL 	NXT+1 		;(vacating the lo bit, which will be used for the quotient)
 		ROL 	RES
 		ROL 	RES+1
 		LDA 	RES
 		SEC 			;Trial subtraction
 		SBC 	TOS
 		TAY
 		LDA 	RES+1
 		SBC 	TOS+1
 		BCC 	CalcDivL2 	;Did subtraction succeed?
 		STA 	RES+1 		;If yes, save it
 		STY 	RES
 		INC 	NXT 		;and record a 1 in the quotient
CalcDivL2 	DEX
 		BNE 	CalcDivL1
 		;--
 		;-- ** copy NXT-> TOS, then fix TOS *************************************
 		LDA 	NXT
 		LDX 	NXT+1
 		JSR 	CalcFix
 		JMP 	CalcSetI 	; AX -> TOS
;--------------------------------------------------------------------- CalcModI
CalcModI: ; TOS = NXT % TOS
 		JSR 	CalcDivI 	; divide with remainder in RES
 		;-- fall through to get remainder into TOS
;--------------------------------------------------------------------- CalcRemI
CalcRemI: ; Remainder of division into TOS (also in AX) - Call CalcDivI before
 		LDA 	RES
 		LDX 	RES+1
 		JMP 	CalcSetI
;--------------------------------------------------------------------- CalcD10
CalcD10TOS: ; TOS = TOS / 10, remainder in A [AXY]
 		LDX 	#TOS
CalcD10 	; Divide value at 0,X  by 10, remainder in A [AY]
;432cy (without .x drops to 396cy)
;for 24 bit, ldy #24 and add include the rol 02,X
 		LDY 	#16 		; make this 24 for 24 bit version
 		LDA 	#0
 		CLC
CalcD101 	ROL 	a
 		CMP 	#10
 		BCC 	CalcD102
 		SBC 	#10
CalcD102 	ROL 	$00,X 		; TOS
 		ROL 	$01,X 		; TOS+1
 		;-- rol $01,X		    ; TOS+2  - include for 24 bit version
 		DEY
 		BPL 	CalcD101
 		RTS

;--------------------------------------------------------------------- CalcStr
CalcStr: ; convert TOS to string in RES (Padded with zeroes)
 		;-- abs of TOS, sign in SGN
 		LDX 	#TOS
 		JSR 	CalcAbsX
 		;-- TOS to digits in RES
 		LDX 	#8
 		LDA 	#0
 		STA 	RES,x
 		DEX
 		STA 	RES,x
 		DEX
CalcStrL 	PHX
 		JSR 	CalcD10TOS
 		PLX
 		ORA 	#'0'
 		STA 	RES,x
 		DEX
 		BPL 	CalcStrL
 		;-- Place sign in RES[0] based on SGN
 		LDA 	#'+'
 		LDY 	SGN
 		BPL 	CalcStrX
 		LDA 	#'-'
CalcStrX 	STA 	RES
 		RTS

;--------------------------------------------------------------------- CalcMul10
CalcMul10: ; TOS = TOS * 10 (preserves all registers)
;81cycles
 		PHA
 		LDA 	TOS
 		STA 	RES
 		LDA 	TOS+1
 		STA 	RES+1 		; RES = TOS
 		ASL 	RES
 		ROL 	RES+1 		; RES = 2*TOS
 		ASL 	RES
 		ROL 	RES+1 		; RES = 4*TOS
 		CLC
 		LDA 	TOS
 		ADC 	RES
 		STA 	TOS
 		LDA 	TOS+1
 		ADC 	RES+1
 		STA 	TOS+1 		;TOS = 5*TOS
 		ASL 	TOS
 		ROL 	TOS+1 		;TOS = 10*TOS
 		PLA
 		RTS

PARAGRAPH()
;--------------------------------------------------------------------- CalcParseAX
;CalcParseAX: ; Parse value in string at AX (null terminated) -> TOS
; 		STAX(Z_Rd)
;--------------------------------------------------------------------- CalcParse
; Read string (CharRd) and parse into number value -> TOS
 		;-- $1999 max that can multiply by 10 and not over flow (65535/10)
 		;-- so high <= $18 should be ok $18FF(6399) * 10 => $F9F6(63990)
 		;-- $0FFF is safe (4095 * 10=> 40950) $9FF6
CalcParse: ; Read string (CharRd) and parse into number value -> TOS
 		JSR 	CalcZero 	; TOS=0, SGN=0(+), EXP=$40, DIG=0

CalcParseL 	JSR 	CharRd 		; Read next character in
 		BEQ 	CalcParseX 	; null -> exit
 		;-- '+' ignore (default sign) get next
 		CMP 	#'+'
 		BEQ 	CalcParseL 	; +ve, ok, next char
 		;-- '-' note sign and get next
 		CMP 	#'-'
 		BNE 	CalcParse1
 		;-- place sign bit in EXP
 		LDA 	#$C0 		; -ve, E=0
 		STA 	EXP
 		BRA 	CalcParseL
CalcParse1 	;-- check for '.'
 		CMP 	#'.'
 		BNE 	CalcParse2
 		;-- decimal point - set up to count digits after it
 		LDA 	#$80
 		STA 	DIG
 		BRA 	CalcParseL 	; loop back for next char

CalcParse2 	; check for 'E' notation  (must use uppercase 'E')
 		CMP 	#'E'
 		BNE 	CalcParse3
 		;--
 		JSR 	CalcExp 	; read [+/-] digits into A as signed short
 		CLC
 		ADC 	EXP
 		STA 	EXP
 		JMP 	CalcParseX 	; jump out to adjust based on digits after '.'

CalcParse3 	; check for digits 0-9
 		CMP 	#$3A
 		BPL 	CalcParseX 	; >'9' -> exit
 		CMP 	#$30
 		BMI 	CalcParseX 	; <'0' -> exit
 		;-- we have a digit in .A
 		TAX 			; save digit character
 		;-- count digits after the decimal point
 		LDA 	DIG
 		BPL 	CalcParse4 	; not decimal point yet, so don't count
 		INC 	DIG 		; count another digit after the point

CalcParse4 	;-- another digit

 		;-- check if we have space for another digit in TOS
 		LDA 	TOS+2 		; top byte of TOS
 		AND 	#$F0
 		BEQ 	CalcParse5 	; got space so go mult x 10 and add
 		;-- TOS is full so adjust E
 		INC 	EXP
 		BRA 	CalcParseL 	; loop back for more digits

CalcParse5 	; we have space, so roll it in (leaving E at 0 for now)
 		TXA 			; recall the digit character
 		JSR 	CalcMul10 	; TOS = TOS * 10 (preserves AXY)
 		CLC
 		AND 	#$0F
 		ADC 	TOS 		; add digit value to TOS
 		STA 	TOS
 		BCC 	CalcParseL
 		INC 	TOS+1
 		BCC 	CalcParseL
 		INC 	TOS+2
 		BRA 	CalcParseL

CalcParseX 	; done with valid characters, adjust E based on places after the point
 		LDA 	DIG 		; bit 7 is '1' if we had a '.'
 		BPL 	CalcParseX1 	; no '.' so we're done
 		AND 	#$7F 		; mask off the flag
 		SEC
 		LDA 	EXP
 		SBC 	DIG
 		STA 	EXP 		; EXP = EXP - DIG

CalcParseX1 	RTS

;	 	LDA 	TOS
; 		LDX 	TOS+1
; 		JSR 	CalcFix
; 		JMP 	CalcSetI


;--------------------------------------------------------------------- CalcExp
CalcExp: ; Reads [+/-][0..9*] return value in A (no error checking)
 		STZ 	NUM 		; $64 $xx
 		STZ 	SGN 		; assume +ve
CalcExpL
 		JSR 	CharRd
 		BEQ 	CalcExpX
 		;-- '+' ignore (default sign) get next
 		CMP 	#'+'
 		BEQ 	CalcExpL 	; +ve, ok, next char
 		;-- '-' note sign and get next
 		CMP 	#'-'
 		BNE 	CalcExp1
 		;-- set sign flag
 		LDA 	#$FF
 		STA 	SGN
 		BRA 	CalcExpL
CalcExp1
 		CMP 	#$3A
 		BPL 	CalcExpX 	; >'9' -> exit
 		CMP 	#$30
 		BMI 	CalcExpX 	; <'0' -> exit
 		;-- we have a digit in .A
 		TAY 			; save digit in Y
 		LDA 	NUM
 		ASL 	A 		; A = NUM * 2
 		ASL 	A 		; A= NUM *4
 		CLC
 		ADC 	NUM 		; A = NUM * 5
 		ASL 	A
 		STA 	NUM 		; NUM = NUM * 10
 		;--
 		TYA 			; get digit back
 		AND 	#$0F 		; strip the value out
 		CLC
 		ADC 	NUM
 		STA 	NUM 		; NUM = NUM + digit
 		;--
 		BRA 	CalcExp1 	; get more digits

CalcExpX 	; we have the value in NUM, and sign in SGN
 		LDA 	SGN
 		BPL 	CalcExpX1 	; poistive
 		;-- convert to 2's complement
 		LDA 	NUM
 		EOR 	#$FF
 		INC 	A
 		STA 	NUM

CalcExpX1 	LDA 	NUM
 		RTS




;--------------------------------------------------------------------- CalcI2F
CalcI2F: ; Covert TOS from Int to float
 		JSR 	CalcAbsTOS 	; sign in Y
 		TYA
 		AND 	#$80 		; Sign is top bit 1:-ve 0:+ve
 		ORA 	#$40 		; Exp is offset $40 (so E-63 ... E+63)
 		STA 	TOS+2 		; save EXP flag in TOS3
 		RTS

;--------------------------------------------------------------------- CalcStrF
CalcStrF: ; Covert float to string in RES
;RES  0   1   2   3   4   5   6   7   8   9   10   11   12
;     SS '0' '3' '2' '7' '6' '7'  00
 		;-- get exponent into EXP
 		LDA 	TOS+2
 		PHA
 		;-- convert mantisa part (with sign)
 		JSR 	CalcStr
 		PLA 			;restore EXP byte
 		AND 	#$7F 		;mask off the mantissa sign
 		SEC
 		SBC 	#$40 		;subtract offset (now signed binary)
 		STA 	EXP 		; save exponent value
 		;-- find first non '0'
 		LDY 	#1
 		LDX 	#1
CalcStrF1 	LDA 	RES,x
 		CMP 	#'0'
 		BNE 	CalcStrF2
 		INX
 		CPX 	#6 		; want at least one digit
 		BNE 	CalcStrF1
 		LDA 	RES,x
 		;-- first non-zero digit
CalcStrF2 	STA 	RES,y
 		INY
 		INX
 		LDA 	RES,x
 		BEQ 	CalcStrF4
 		;-- place the point
 		LDA 	#'.'
 		STA 	RES,y
 		INY
 		;-- copy & adjust E
CalcStrF3 	LDA 	RES,x
 		BEQ 	CalcStrF4 	; null = done
 		STA 	RES,y
 		INX
 		INY
 		INC 	EXP
 		CPX 	#7 		; end
 		BNE 	CalcStrF3
 		;-- now for the E
CalcStrF4 	LDA 	#'E'
 		STA 	RES,y
 		INY
 		;-- exp sign
 		LDX 	#'+'
 		LDA 	EXP
 		BPL 	CalcStrF5
 		LDX 	#'-'
 		EOR 	#$FF
 		INC 	A
CalcStrF5 	STA 	EXP
 		;-- sign char to RES[y++]
 		TXA
 		STA 	RES,y
 		INY
 		;-- EXP to bcd
 		LDA 	EXP
 		AND 	#$7F
 		JSR 	Bin2Dec
 		PHA 			;Save A for LSD
 		LSR 	a
 		LSR 	a
 		LSR 	a 		; MSD to LSD position
 		LSR 	a
 		ORA 	#'0'
 		STA 	RES,y
 		INY
 		PLA 			; Restore A and then
 		AND 	#$0F
 		ORA 	#'0'
 		STA 	RES,y
 		INY
 		LDA 	#0
 		STA 	RES,Y
 		RTS


;--------------------------------------------------------------------- CvtFloat
CvtFloat: ; Convert TOS to Float String and write to output (CharWr)
 		JSR 	CalcStrF
 		LDAX(RES)
 		JMP 	CharAppendAX 	; append contents of RES to the output buffer

;--------------------------------------------------------------------- CvtInt
CvtInt: ; Convert TOS to integer String and write to output (CharWr)
 		JSR 	CalcStr
 		LDAX(RES)
 		JMP 	CharAppendAX 	; append contents of RES to the output buffer

.export Calc, CalcParse



#ifdef DBUG
CalcDBugTOS: ; dump TOS
;===================================================================== CALC DBUG
 		LDX 	#TOS
;--------------------------------------------------------------------- CalcDBug
CalcDBug: ; sends raw form of TOS to screen
 		LDA 	_EXP,X
 		JSR 	DBugHex
 		LDA 	#':'
 		JSR 	CharOut
 		LDA 	_MU,X
 		JSR 	DBugHex
 		LDA 	_MH,X
 		JSR 	DBugHex
 		LDA 	_ML,X
 		JSR 	DBugHex
 		;--
 		LDA 	#' '
 		JSR 	CharOut
 		LDA 	_SGN,X
 		JSR 	DBugHex
 		;--
 		JMP 	OutNL
#endif

;.export Calc,CalcAbs,CalcAbsNXT,CalcAbsTOS,CalcAddI,CalcCmpl,CalcD10,CalcDivI
;.export CalcDrop,CalcDup,CalcFix,CalcGetI,CalcI2F,CalcModI,CalcMul10,CalcMulI
;.export CalcNext,CalcParse,CalcParseAX,CalcPop,CalcPush,CalcRemI,CalcSetI
;.export CalcSign,CalcStr,CalcSubI,CalcZero



.echo $-Calc
.echo " bytes for Calc.a65\r"
#endif
#endif
