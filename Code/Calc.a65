.NOLIST
; Calc
;
;

#if ($>>8)==0
 .org ($+16)/16 * 16
.LIST
;------------------------------- Calc Z-Page
Var(TOS,4)              ; Top-Of-Stack
Var(NXT,4)              ; Next item on stack
Var(RES,8)              ; Result
Short(CSP)              ; Calc stack pointer (00->0F)
Short(SGN)
.NOLIST
#endif

#if ($>>8)==1
.LIST
;------------------------------- Calc stack space
; resides below the cpu stack 64 bytes - leaves 192 for cpu
; this is a split stack
Var(CSTK0,16)           ; Stack for LSB
Var(CSTK1,16)
Var(CSTK2,16)
Var(CSTK3,16)           ; Stack for MSB
.NOLIST
#endif


#if CODEPAGE
#ifndef _Calc
#define _Calc

TOS0 = TOS
TOS1 = TOS+1
TOS2 = TOS+2
TOS3 = TOS+3


.LIST
;================================================================ CALC
Calc:;Initialise calculator [A]
            lda #0              ; Init calc stack pointer
            sta CSP
;---------------------------------------------------------------- CalcZero
CalcZero:; Zero TOS & SGN [A]
            lda #0
            sta TOS
            sta TOS+1
            sta TOS+2
            sta TOS+3
            sta SGN
            rts
;---------------------------------------------------------------- CalcFix
CalcFix:; Fix sign of AX based on SGN (if SGN-ve, then Complement)
			ldy	SGN				; N=1 if -ve
			bmi CalcCmpl		; -ve so go and complement
			rts					; otherwise +ve and we're ok as is
;---------------------------------------------------------------- CalcAbs
CalcAbs:; Return sign in Y (0=+, 1=-) and and value in AX
			ldy	#0
			cpx #$80
			bcc CalcCmplX		; positive so exit y=0 (+ve)
			dey					; negative, so make y=$FF (-ve)
			; fall through to complement AX
;---------------------------------------------------------------- CalcCmplAX
CalcCmpl:; Two's compliment of AX (A=Lo, X=Hi)
			eor #$FF
			pha
			txa
			eor #$FF
			tax
			pla
			inc A
			bne CalcCmplX
			inx
CalcCmplX	rts
;---------------------------------------------------------------- CalcDup
CalcDup:; Duplicate TOS (=Push TOS)
;---------------------------------------------------------------- CalcPush
CalcPush:; Push TOS onto the stack [AX]
            ldx CSP
            lda TOS+0
            sta CSTK0,X
            lda TOS+1
            sta CSTK1,X
            lda TOS+2
            sta CSTK2,X
            lda TOS+3
            sta CSTK3,X
            ; force CSP to 0-15
            lda CSP
            inc A
            and #$0F
            sta CSP
            rts
;---------------------------------------------------------------- CalcDrop
CalcDrop:; Pop item into TOS item variable
            jsr CalcPop
            ;
            lda CSTK0,X
            sta TOS+0
            lda CSTK1,X
            sta TOS+1
            lda CSTK2,X
            sta TOS+2
            lda CSTK3,X
            sta TOS+3
            rts

;---------------------------------------------------------------- CalcPop
CalcPop:; Reduce stack pointer, .X points to 'popped' item
            ; force CSP to 0-15
            lda CSP
            dec A
            and #$0F
            sta CSP
            ;
            ldx CSP
            rts

;---------------------------------------------------------------- CalcNext
CalcNext:; Pop item into NXT item variable
            jsr CalcPop
            ;
            lda CSTK0,X
            sta NXT+0
            lda CSTK1,X
            sta NXT+1
            lda CSTK2,X
            sta NXT+2
            lda CSTK3,X
            sta NXT+3
            rts

;---------------------------------------------------------------- CalcSetI
CalcSetI:; TOS = AX (16 bit signed integer A=lo,X=hi) [AY]
			sta	TOS+0
			stx TOS+1
			ldy #0
			sty TOS+2			; clear high bytes
			sty TOS+3
			rts
;---------------------------------------------------------------- CalcGetI
CalcGetI:; Return TOS in AX (16 bit signed integer A=lo,X=hi)
			lda	TOS+0
			ldx TOS+1
			rts

;---------------------------------------------------------------- CalcAddI
CalcAddI:; TOS = NXT + TOS	(16 bit signed integer)
			jsr CalcPop			; Pop but access onstack with X
			clc
			lda CSTK0,X
			adc TOS+0
			sta TOS+0
			;
			lda CSTK1,X
			adc TOS+1
			sta TOS+1
			;
			rts

;---------------------------------------------------------------- CalcSubI
CalcSubI:; TOS = NXT - TOS	(16 bit signed integer)
			jsr CalcPop			; Pop but access onstack with X
			sec
			lda CSTK0,X
			sbc TOS+0
			sta TOS+0
			;
			lda CSTK1,X
			sbc TOS+1
			sta TOS+1
			;
			rts
;---------------------------------------------------------------- CalcSign
CalcSign:; Set Result SGN and make TOS & NXT positive
			;-- TOS
			lda	TOS+0
			ldx TOS+1
			jsr CalcAbs
			sta TOS+0
			stx TOS+1
			sty SGN
			;-- NXT
			lda NXT+0
			ldx NXT+1
			jsr CalcAbs
			sta NXT+0
			stx NXT+1
			tya
			eor SGN
			sta SGN
			rts

;---------------------------------------------------------------- CalcMulI
CalcMulI:; TOS = NXT * TOS	(16 bit signed integer)
; 726 cycles for 123 * 27
			jsr CalcNext		; pop into NXT
			jsr CalcSign
			;
        	lda #0       		;Initialize RES to 0
        	sta RES+2
        	ldx #16      		;There are 16 bits in TOS
CalcMulI1   lsr TOS+1    		;Get low bit of TOS
        	ror TOS
        	bcc CalcMulI2       ;0 or 1?
        	tay          		;If 1, add NXT (hi byte of RES is in A)
        	clc
        	lda NXT
        	adc RES+2
        	sta RES+2
        	tya
        	adc NXT+1
CalcMulI2   ror A        		; shift
        	ror RES+2
        	ror RES+1
        	ror RES
        	dex
       	 	bne CalcMulI1
        	sta RES+3
        	;- place result in TOS
        	lda RES
        	ldx RES+1
        	jsr CalcFix
        	jmp CalcSetI		; AX -> TOS

;---------------------------------------------------------------- CalcDivI
CalcDivI:; TOS = NXT / TOS	(16 bit signed integer)
			jsr CalcNext		; pop into NXT
			jsr CalcSign

; NXT / TOS => NXT, remainder in RES
			lda #0      ;Initialize RES to 0
			sta RES
			sta RES+1
			ldx #16     ;There are 16 bits in NXT
CalcDivL1   asl NXT    ;Shift hi bit of NXT into RES
			rol NXT+1  ;(vacating the lo bit, which will be used for the quotient)
			rol RES
			rol RES+1
			lda RES
			sec         ;Trial subtraction
			sbc TOS
			tay
			lda RES+1
			sbc TOS+1
			bcc CalcDivL2      ;Did subtraction succeed?
			sta RES+1   ;If yes, save it
			sty RES
			inc NXT    ;and record a 1 in the quotient
CalcDivL2   dex
			bne CalcDivL1
			;
			lda NXT
			ldx NXT+1
        	jsr CalcFix
        	jmp CalcSetI		; AX -> TOS
;---------------------------------------------------------------- CalcModI
CalcModI:; TOS = NXT % TOS
			jsr	CalcDivI		; divide with remainder in RES
			; fall through to get remainder into TOS
;---------------------------------------------------------------- CalcRemI
CalcRemI:; Remainder of division into TOS (also in AX) - Call CalcDivI before
			lda RES
			ldx RES+1
			jmp	CalcSetI
;---------------------------------------------------------------- CalcD10
CalcD10:; Divide TOS by 10, remainder in A
			ldy #16
			lda #0
			clc
CalcD101 	rol a
			cmp #10
			bcc CalcD102
			sbc #10
CalcD102 	rol TOS
			rol TOS+1
			dey
			bpl CalcD101
			rts

;---------------------------------------------------------------- CalcStr
CalcStr:; convert TOS to string in RES
			;-- abs of TOS, sign in SGN
			lda	TOS+0
			ldx TOS+1
			jsr CalcAbs
			sta TOS+0
			stx TOS+1
			sty SGN
			ldx #5
CalcStrL	jsr CalcD10			; Divide TOS by 10, remainder in A
			ora #'0'
			sta RES,x
			dex
			bpl CalcStrL
			;-- add the sign
			lda #'+'
			ldy SGN
			bpl CalcStrX
			lda #'-'
CalcStrX	sta RES
			rts

;---------------------------------------------------------------- CalcMul10
CalcMul10:; TOS = TOS * 10
			;--TOS x 10
			clc
			rol TOS
			rol TOS+1			; TOS = TOS *2
			lda TOS
			sta RES
			lda TOS+1
			sta RES+1			; RES = TOS * 2
			clc
			rol TOS
			rol TOS+1			; TOS = TOS * 4
			clc
			rol TOS
			rol TOS+1			; TOS = TOS * 8
			;
			clc
			lda RES
			adc TOS
			sta TOS
			lda RES+1
			adc TOS+1
			sta TOS+1			; TOS = 10 x TOS
			;--
			rts

;---------------------------------------------------------------- CalcParseAX
CalcParseAX:; Parse value in string at AX (null terminated) -> TOS
			STAX(Z_Ptr)
;---------------------------------------------------------------- CalcParse
CalcParse:; Parse value in string at Z_Ptr (null terminated) -> TOS
			jsr CalcZero		; TOS=0, SGN=0
			ldy #255
CalcParseL	iny
			bmi CalcParseX		; too long -> exit (more than 127 chars!!)
			;
			lda (Z_Ptr),y		; get char
			beq CalcParseX		; null -> exit

			cmp #'+'
			beq CalcParseL		; +ve, ok

			cmp #'-'
			beq CalcParseNeg	; -ve, ok

			cmp #$3A
			bpl CalcParseX		; >'9' -> exit
			cmp #$30
			bmi CalcParseX		; <'0' -> exit
			pha

			jsr CalcMul10

			pla
			clc
			and #$0F
			adc TOS				; add digit value to TOS
			sta TOS
			bcc CalcParseL
			inc TOS+1
			bra CalcParseL

CalcParseNeg
			lda #$FF
			sta SGN
			bra CalcParseL

CalcParseX	lda	TOS
			ldx	TOS+1
			jsr CalcFix
			jmp CalcSetI

.echo $-Calc
.echo " bytes for Calc.a65\r"
#endif
#endif
