.NOLIST
; Calc
;Calc        Initialise calculator [A]
;CalcAbs     Return sign in Y (0=+, 1=-) and and value in AX
;CalcAbsNXT  Cvt TOS to absolute, with sign in Y
;CalcAbsTOS  Cvt TOS to absolute, with sign in .Y and SGN
;CalcAddI    TOS = NXT + TOS (16 bit signed integer)
;CalcCopy    Copy value from Z,X to Z,Y
;CalcCmpl    Two's compliment of AX (A=Lo, X=Hi)
;CalcD10     TOS = TOS / 10, remainder in A
;CalcDivI    TOS = NXT / TOS (16 bit signed integer)
;CalcDrop    Pop item into TOS item variable
;CalcDup     Duplicate TOS (=Push TOS)
;CalcFix     Fix sign of AX based on SGN (if SGN-ve, then Complement)
;CalcGetI    Return TOS in AX (16 bit signed integer A=lo,X=hi)
;CalcI2F     Covert TOS from Int to float
;CalcModI    TOS = NXT % TOS
;CalcMul10   TOS = TOS * 10
;CalcMulI    TOS = NXT * TOS (16 bit signed integer)
;CalcNext    Pop item into NXT item variable
;CalcParse   Parse value in string at Z_Ptr (null terminated) -> TOS
;CalcParseAX Parse value in string at AX (null terminated) -> TOS
;CalcPop     Reduce stack pointer, .X points to 'popped' item
;CalcPush    Push TOS onto the stack [AX]
;CalcRemI    Remainder of division into TOS (also in AX) - Call CalcDivI before
;CalcSetI    TOS = AX (16 bit signed integer A=lo,X=hi) [AY]
;CalcSign    Set Result SGN and make TOS & NXT positive
;CalcStr     convert TOS to string in RES
;CalcSubI    TOS = NXT - TOS (16 bit signed integer)
;CalcZero    Zero TOS & SGN [A]


#if ($>>8)==0
.org ($+16)/16 * 16
.LIST
;--------------------------------------------------------------------- Calc Z-Page
Var(RES,16) 	; Result
Var(TOS,4) 	; Top-Of-Stack
Var(NXT,4) 	; Next item on stack
Short(SGN) 	; sign
Short(EXP) 	; exponent
Short(DIG) 	; digits counter
Short(CSP) 	; Calc stack pointer (00->0F)
.NOLIST
#endif

#if ($>>8)==1
.LIST
;--------------------------------------------------------------------- Calc stack space
; resides below the cpu stack 64 bytes - leaves 192 for cpu
; this is a split stack
Var(CSTK0,16) 	; Stack for LSB
Var(CSTK1,16)
Var(CSTK2,16)
Var(CSTK3,16) 	; Stack for MSB
.NOLIST
#endif


#if CODEPAGE
#ifndef _Calc
#define _Calc

.LIST
;===================================================================== CALC
Calc 		;Initialise calculator [A]
 		LDA 	#0 		; Init calc stack pointer
 		STA 	CSP
;--------------------------------------------------------------------- CalcZero
CalcZero 	; Zero TOS & SGN [A]
 		LDA 	#0
 		STA 	TOS
 		STA 	TOS+1
 		STA 	TOS+2
 		STA 	TOS+3
 		STA 	SGN
 		LDA 	EXP
 		RTS

;***** Change these to only work on TOS ****************************************************
;--------------------------------------------------------------------- CalcFix
CalcFix 	; Fix sign of AX based on SGN (if SGN-ve, then Complement)
 		LDY 	SGN 		; N=1 if -ve
 		BMI 	CalcCmpl 	; -ve so go and complement
 		RTS 			; otherwise +ve and we're ok as is

;--------------------------------------------------------------------- CalcAbs
CalcAbs 	; Return sign in Y (0=+, 1=-) and and value in AX
 		LDY 	#0
 		CPX 	#$80
 		BCC 	CalcCmplX 	; positive so exit y=0 (+ve)
 		DEY 			; negative, so make y=$FF (-ve)
	 	;-- fall through to complement AX
;--------------------------------------------------------------------- CalcCmplAX
CalcCmpl 	; Two's compliment of AX (A=Lo, X=Hi)
 		EOR 	#$FF
 		PHA
 		TXA
 		EOR 	#$FF
 		TAX
 		PLA
 		INC 	A
 		BNE 	CalcCmplX
 		INX
CalcCmplX 	RTS



;--------------------------------------------------------------------- CalcDup
CalcDup 	; Duplicate TOS (=Push TOS)
;--------------------------------------------------------------------- CalcPush
CalcPush 	; Push TOS onto the stack [AX]
 		LDX 	CSP
 		LDA 	TOS+0
 		STA 	CSTK0,X
 		LDA 	TOS+1
 		STA 	CSTK1,X
 		LDA 	TOS+2
 		STA 	CSTK2,X
 		LDA 	TOS+3
 		STA 	CSTK3,X
	 	;-- force CSP to 0-15
 		LDA 	CSP
 		INC 	A
 		AND 	#$0F
 		STA 	CSP
 		RTS
;--------------------------------------------------------------------- CalcDrop
CalcDrop 	; Pop item into TOS item variable
 		JSR 	CalcPop
	 	;-- 
 		LDA 	CSTK0,X
 		STA 	TOS+0
 		LDA 	CSTK1,X
 		STA 	TOS+1
 		LDA 	CSTK2,X
 		STA 	TOS+2
 		LDA 	CSTK3,X
 		STA 	TOS+3
 		RTS

;--------------------------------------------------------------------- CalcRES2TOS
CalcRES2TOS 	; Copy RES to TOS
 		LDX 	#RES
 		BRA 	CalcToTOS
;--------------------------------------------------------------------- CalcNXT2TOS
CalcNXT2TOS 	; Copy NXTS to TOS
 		LDX 	#RES
;--------------------------------------------------------------------- CalcToTOS
CalcToTOS 	LDX 	#TOS
;--------------------------------------------------------------------- CalcCopy
CalcCopy 	; Copy value from Z,X to Z,Y
 		LDA 	$00,X
 		STA 	$00,Y
 		LDA 	$01,X
 		STA 	$01,Y
 		LDA 	$02,X
 		STA 	$02,Y
 		LDA 	$03,X
 		STA 	$03,Y
 		RTS

;--------------------------------------------------------------------- CalcPop
CalcPop 	; Reduce stack pointer, .X points to 'popped' item
	 	;-- force CSP to 0-15
 		LDA 	CSP
 		DEC 	A
 		AND 	#$0F
 		STA 	CSP
 		TAX
 		RTS

;--------------------------------------------------------------------- CalcNext
CalcNext 	; Pop item into NXT item variable
 		JSR 	CalcPop
	 	;-- 
 		LDA 	CSTK0,X
 		STA 	NXT+0
 		LDA 	CSTK1,X
 		STA 	NXT+1
 		LDA 	CSTK2,X
 		STA 	NXT+2
 		LDA 	CSTK3,X
 		STA 	NXT+3
 		RTS

;--------------------------------------------------------------------- CalcSetI
CalcSetI 	; TOS = AX (16 bit signed integer A=lo,X=hi) [AY]
 		STA 	TOS+0
 		STX 	TOS+1
 		LDY 	#0
 		STY 	TOS+2 		; clear high bytes
 		STY 	TOS+3
 		RTS
;--------------------------------------------------------------------- CalcGetI
CalcGetI 	; Return TOS in AX (16 bit signed integer A=lo,X=hi)
 		LDA 	TOS+0
 		LDX 	TOS+1
 		RTS

;--------------------------------------------------------------------- CalcAddI
CalcAddI 	; TOS = NXT + TOS	(16 bit signed integer)
 		JSR 	CalcPop 	; Pop but access onstack with X
 		CLC
 		LDA 	CSTK0,X
 		ADC 	TOS+0
 		STA 	TOS+0
	 	;-- 
 		LDA 	CSTK1,X
 		ADC 	TOS+1
 		STA 	TOS+1
	 	;-- 
 		RTS

;--------------------------------------------------------------------- CalcSubI
CalcSubI 	; TOS = NXT - TOS	(16 bit signed integer)
 		JSR 	CalcPop 	; Pop but access onstack with X
 		SEC
 		LDA 	CSTK0,X
 		SBC 	TOS+0
 		STA 	TOS+0
	 	;-- 
 		LDA 	CSTK1,X
 		SBC 	TOS+1
 		STA 	TOS+1
	 	;-- 
 		RTS

;--------------------------------------------------------------------- CalcAbsTOS
CalcAbsTOS 	; Cvt TOS to absolute, with sign in .Y and SGN
 		LDA 	TOS
 		LDX 	TOS+1
 		JSR 	CalcAbs
 		STA 	TOS
 		STX 	TOS+1
 		STY 	SGN
 		RTS

;--------------------------------------------------------------------- CalcAbsNXT
CalcAbsNXT 	; Cvt TOS to absolute, with sign in Y
 		LDA 	NXT+0
 		LDX 	NXT+1
 		JSR 	CalcAbs
 		STA 	NXT+0
 		STX 	NXT+1
 		RTS

;--------------------------------------------------------------------- CalcSign
CalcSign 	; Set Result SGN and make TOS & NXT positive
	 	;-- -- TOS
 		JSR 	CalcAbsTOS
 		JSR 	CalcAbsNXT
 		TYA
 		EOR 	SGN
 		STA 	SGN
 		RTS

;--------------------------------------------------------------------- CalcMulI
CalcMulI 	; TOS = NXT * TOS	(16 bit signed integer)
; 726 cycles for 123 * 27
 		JSR 	CalcNext 	; pop into NXT
 		JSR 	CalcSign
	 	;-- 
 		LDA 	#0 		;Initialize RES to 0
 		STA 	RES+2
 		LDX 	#16 		;There are 16 bits in TOS
CalcMulI1 	LSR 	TOS+1 		;Get low bit of TOS
 		ROR 	TOS
 		BCC 	CalcMulI2 	;0 or 1?
 		TAY 			;If 1, add NXT (hi byte of RES is in A)
 		CLC
 		LDA 	NXT
 		ADC 	RES+2
 		STA 	RES+2
 		TYA
 		ADC 	NXT+1
CalcMulI2 	ROR 	A 		; shift
 		ROR 	RES+2
 		ROR 	RES+1
 		ROR 	RES
 		DEX
 		BNE 	CalcMulI1
 		STA 	RES+3
	 	;-- - place result in TOS
	 	;-- 
	 	;-- ** copy RES->TOS, then fix TOS *************************************
 		LDA 	RES
 		LDX 	RES+1
 		JSR 	CalcFix
	 	;-- 
 		JMP 	CalcSetI 	; AX -> TOS

;--------------------------------------------------------------------- CalcDivI
CalcDivI 	; TOS = NXT / TOS	(16 bit signed integer)
 		JSR 	CalcNext 	; pop into NXT
 		JSR 	CalcSign

; NXT / TOS => NXT, remainder in RES
 		LDA 	#0 		;Initialize RES to 0
 		STA 	RES
 		STA 	RES+1
 		LDX 	#16 		;There are 16 bits in NXT
CalcDivL1 	ASL 	NXT 		;Shift hi bit of NXT into RES
 		ROL 	NXT+1 		;(vacating the lo bit, which will be used for the quotient)
 		ROL 	RES
 		ROL 	RES+1
 		LDA 	RES
 		SEC 			;Trial subtraction
 		SBC 	TOS
 		TAY
 		LDA 	RES+1
 		SBC 	TOS+1
 		BCC 	CalcDivL2 	;Did subtraction succeed?
 		STA 	RES+1 		;If yes, save it
 		STY 	RES
 		INC 	NXT 		;and record a 1 in the quotient
CalcDivL2 	DEX
 		BNE 	CalcDivL1
	 	;-- 
	 	;-- ** copy NXT-> TOS, then fix TOS *************************************
 		LDA 	NXT
 		LDX 	NXT+1
 		JSR 	CalcFix
 		JMP 	CalcSetI 	; AX -> TOS
;--------------------------------------------------------------------- CalcModI
CalcModI 	; TOS = NXT % TOS
 		JSR 	CalcDivI 	; divide with remainder in RES
	 	;-- fall through to get remainder into TOS
;--------------------------------------------------------------------- CalcRemI
CalcRemI 	; Remainder of division into TOS (also in AX) - Call CalcDivI before
 		LDA 	RES
 		LDX 	RES+1
 		JMP 	CalcSetI
;--------------------------------------------------------------------- CalcD10
CalcD10TOS 	; TOS = TOS / 10, remainder in A [AXY]
 		LDX 	#TOS
CalcD10 	; Divide value at 0,X  by 10, remainder in A [AY]
;432cy (without .x drops to 396cy)
;for 24 bit, ldy #24 and add include the rol 02,X
 		LDY 	#16 		; make this 24 for 24 bit version
 		LDA 	#0
 		CLC
CalcD101 	ROL 	a
 		CMP 	#10
 		BCC 	CalcD102
 		SBC 	#10
CalcD102 	ROL 	$00,X 		; TOS
 		ROL 	$01,X 		; TOS+1
	 	;-- rol $01,X		    ; TOS+2  - include for 24 bit version
 		DEY
 		BPL 	CalcD101
 		RTS

;--------------------------------------------------------------------- CalcStr
CalcStr 	; convert TOS to string in RES (Padded with zeroes)
	 	;-- -- abs of TOS, sign in SGN
 		LDA 	TOS+0
 		LDX 	TOS+1
 		JSR 	CalcAbs
 		STA 	TOS+0
 		STX 	TOS+1
 		STY 	SGN
	 	;-- -- TOS to digits in RES
 		LDX 	#8
 		LDA 	#0
 		STA 	RES,x
 		DEX
 		STA 	RES,x
 		DEX
CalcStrL 	PHX
 		JSR 	CalcD10TOS
 		PLX
 		ORA 	#'0'
 		STA 	RES,x
 		DEX
 		BPL 	CalcStrL
	 	;-- -- Place sign in RES[0] based on SGN
 		LDA 	#'+'
 		LDY 	SGN
 		BPL 	CalcStrX
 		LDA 	#'-'
CalcStrX 	STA 	RES
 		RTS

;--------------------------------------------------------------------- CalcMul10
CalcMul10 	; TOS = TOS * 10 (preserves all registers)
;81cycles
 		PHA
 		LDA 	TOS
 		STA 	RES
 		LDA 	TOS+1
 		STA 	RES+1 		; RES = TOS
 		ASL 	RES
 		ROL 	RES+1 		; RES = 2*TOS
 		ASL 	RES
 		ROL 	RES+1 		; RES = 4*TOS
 		CLC
 		LDA 	TOS
 		ADC 	RES
 		STA 	TOS
 		LDA 	TOS+1
 		ADC 	RES+1
 		STA 	TOS+1 		;TOS = 5*TOS
 		ASL 	TOS
 		ROL 	TOS+1 		;TOS = 10*TOS
 		PLA
 		RTS

;--------------------------------------------------------------------- CalcParseAX
CalcParseAX 	; Parse value in string at AX (null terminated) -> TOS
 		STAX(Z_Rd)
;--------------------------------------------------------------------- CalcParse
CalcParse 	; Parse value in string at Z_Ptr (null terminated) -> TOS
 		JSR 	CalcZero 	; TOS=0, SGN=0(+), EXP=0
CalcParseL 	JSR 	CharRd 	; Read next character in
 		BEQ 	CalcParseX 	; null -> exit
	 	;-- '+' ignore (default sign) get next
 		CMP 	#'+'
 		BEQ 	CalcParseL 	; +ve, ok, next char
	 	;-- '-' note sign and get next
 		CMP 	#'-'
 		BNE 	CalcParse1
 		LDA 	#$FF
 		STA 	SGN
 		BRA 	CalcParseL

CalcParse1
 		CMP 	#$3A
 		BPL 	CalcParseX 	; >'9' -> exit
 		CMP 	#$30
 		BMI 	CalcParseX 	; <'0' -> exit
 		JSR 	CalcMul10 	; TOS = TOS * 10 (preserves AXY)
 		CLC
 		AND 	#$0F
 		ADC 	TOS 		; add digit value to TOS
 		STA 	TOS
 		BCC 	CalcParseL
 		INC 	TOS+1
 		BCC 	CalcParseL
 		INC 	TOS+2
 		BRA 	CalcParseL

CalcParseX 	LDA 	TOS
 		LDX 	TOS+1
 		JSR 	CalcFix
 		JMP 	CalcSetI


;--------------------------------------------------------------------- CalcI2F
CalcI2F 	; Covert TOS from Int to float
 		JSR 	CalcAbsTOS 	; sign in Y
 		TYA
 		AND 	#$80 		; Sign is top bit 1:-ve 0:+ve
 		ORA 	#$40 		; Exp is offset $40 (so E-63 ... E+63)
 		STA 	TOS+2 		; save EXP flag in TOS3
 		RTS

;--------------------------------------------------------------------- CalcStrF
CalcStrF 	; Covert float to string in RES
;RES  0   1   2   3   4   5   6   7   8   9   10   11   12
;     SS '0' '3' '2' '7' '6' '7'  00
;--------------------------------------------------------------------- get exponent into EXP
 		LDA 	TOS+2
 		PHA
;--------------------------------------------------------------------- convert mantisa part (with sign)
 		JSR 	CalcStr
 		PLA 			;restore EXP byte
 		AND 	#$7F 		;mask off the mantissa sign
 		SEC
 		SBC 	#$40 		;subtract offset (now signed binary)
 		STA 	EXP 		; save exponent value
;--------------------------------------------------------------------- find first non '0'
 		LDY 	#1
 		LDX 	#1
CalcStrF1 	LDA 	RES,x
 		CMP 	#'0'
 		BNE 	CalcStrF2
 		INX
 		CPX 	#6 		; want at least one digit
 		BNE 	CalcStrF1
 		LDA 	RES,x
;--------------------------------------------------------------------- first non-zero digit
CalcStrF2 	STA 	RES,y
 		INY
 		INX
 		LDA 	RES,x
 		BEQ 	CalcStrF4
	 	;-- place the point
 		LDA 	#'.'
 		STA 	RES,y
 		INY
;--------------------------------------------------------------------- copy & adjust E
CalcStrF3 	LDA 	RES,x
 		BEQ 	CalcStrF4 	; null = done
 		STA 	RES,y
 		INX
 		INY
 		INC 	EXP
 		CPX 	#7 		; end
 		BNE 	CalcStrF3
;--------------------------------------------------------------------- now for the E
CalcStrF4 	LDA 	#'E'
 		STA 	RES,y
 		INY
	 	;-- - exp sign
 		LDX 	#'+'
 		LDA 	EXP
 		BPL 	CalcStrF5
 		LDX 	#'-'
 		EOR 	#$FF
 		INC 	A
CalcStrF5 	STA 	EXP
	 	;-- sign char to RES[y++]
 		TXA
 		STA 	RES,y
 		INY
	 	;-- -- EXP to bcd
 		LDA 	EXP
 		AND 	#$7F
 		JSR 	Bin2Dec
 		PHA 			;Save A for LSD
 		LSR 	a
 		LSR 	a
 		LSR 	a 		; MSD to LSD position
 		LSR 	a
 		ORA 	#'0'
 		STA 	RES,y
 		INY
 		PLA 			; Restore A and then
 		AND 	#$0F
 		ORA 	#'0'
 		STA 	RES,y
 		INY
 		LDA 	#0
 		STA 	RES,Y
 		RTS


;--------------------------------------------------------------------- CvtFloat
CvtFloat 	; Convert TOS to Float String and write to output (CharWr)
 		JSR 	CalcStrF
 		LDAX(RES)
 		JMP 	CharAppendAX 	; append contents of RES to the output buffer

;--------------------------------------------------------------------- CvtInt
CvtInt 		; Convert TOS to integer String and write to output (CharWr)
 		JSR 	CalcStr
 		LDAX(RES)
 		JMP 	CharAppendAX 	; append contents of RES to the output buffer


;.export Calc,CalcAbs,CalcAbsNXT,CalcAbsTOS,CalcAddI,CalcCmpl,CalcD10,CalcDivI
;.export CalcDrop,CalcDup,CalcFix,CalcGetI,CalcI2F,CalcModI,CalcMul10,CalcMulI
;.export CalcNext,CalcParse,CalcParseAX,CalcPop,CalcPush,CalcRemI,CalcSetI
;.export CalcSign,CalcStr,CalcSubI,CalcZero

.export RES,TOS,NXT,SGN,DIG,EXP


.echo $-Calc
.echo " bytes for Calc.a65\r"
#endif
#endif
