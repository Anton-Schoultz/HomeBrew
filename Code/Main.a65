
#include "Macro.a65"			; macro definitions
#include "Vars.a65"				; Z-Page, Stack and system ram
#include "IOMap.a65"			; Define I/O port adresses


ROMBEG .org $E000
;.FILL $2000,$FF
;.org $E000


;			jmp ($,X)
;			nop
;			.dw	addr	; x=4
;			.dw	addr	; x=6
;			.dw	addr	; x=8
;			.dw	addr	; x=10

;------------------------------------------------------------------------- RESET
Reset:		; reset entry point (Cold start)
; cold start initialization
;
			sei					; halt IRQs
			ldx	#$FF			; Set Stack pointer to top of the stack space $0100-01FF
			txs

;------------------------------------------------------------------------- MAIN
; Main loop code
Main:		; Main loop

			;- set outptu to screen
			jsr 	UseConsole

			;- create buffer object at $0300
			LDAX($0300)			; buffer at $0300
			STAX(Z_Ptr)			; point at the buffer  {Z_Ptr is at 00,01}
			lda #29
			jsr	BufInit			; initialise to size of 16

;			;CLI					; Enable IRQs
;
			; point character output to the buffer write
			LDAX(BufWrite)
			STAX(V_CHROUT)

;			LDAX(Msg)			; message addres
;			jsr PrAXHex			; print as hex

			LDAX(Msg)			; message addres
			jsr	PrStr			; 'print' it to the device pointed to by V_CHROUT
;
;			; write to screen
;			jsr	UseConsole
;
;			; point input character to read from buffer
;			LDAX(BufRead)
;			STAX(V_CHRIN)
;
;Show		jsr	GetChar
;			beq	ShowX
;
;			jsr PutChar
;			bra	Show
;
;ShowX



			BRK


UseConsole: ; use console as output
			LDAX(SimPutChar)
			STAX(V_CHROUT)
			rts

GetChar:	; read input character
			jmp (V_CHRIN)

PutChar:	; send character out
			jmp	(V_CHROUT)


;------------------------------------------------------------------------- NMI
Nmi:		; Non-Maskable interrupt entry point
; Negative-edge triggered interrupt
; use this for timer interrupts straight from binary divider ?
			;-- Save registers
			PHA
			PHX
			PHY

; NMI code in here

NmiRtn		;-- Restore registers and return
			PLY
			PLX
			PLA
			RTI


;------------------------------------------------------------------------- IRQ
Irq:		; Interrupt Request servcie routine
; Interrupt low level, reset the source as early as posible
; PC & Status are pushed, then cpu comes here
;
; Serial port Rx ?
			;-- Save registers
			PHA
			PHX
			PHY

; IRQ code in here
; 	reset IRQ source
; 	handle irq

			jsr	BufRead
			beq	IrqRtn			; nothing to show

			jsr SimPutChar		; print character


IrqRtn		;-- Restore registers and return
			PLY
			PLX
			PLA
			RTI					; pop status & PC, return, re-enabling IRQ








Stop:
	brk


Msg: .DB " Hello World\r\nThis is me!",0





VecPutChar:	; Output character as directed
	jsr 	SimPutChar
	rts

#include 	"Buffer.a65"

#include	"Simulator.a65"		; for running on PC simulator
#include 	"Util.a65"
#include 	"MC68B50.a65"		; Define data and code for MC68b50 coms chip

ROMEND = $

;------------------------------------------------------------------------- hardware vectors
; FFFA,B	NMI
; FFFC,D	Reset
; FFFE,F	IRQ
.org $FFFA
.dw Nmi		; Non-Maskable Interrupt
.dw Reset	; Points to reset address (cold start) FFFC,FFFD
.dw Irq		; interrupt vector


.echo ($FFFA - ROMEND) / 256
.echo " pages (x256) available in the 8k ROM. E000-FFFF\r"
	.END